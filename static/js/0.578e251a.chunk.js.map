{"version":3,"sources":["components/Templates/CustomDropdown.js","components/Templates/HoverPreview.js","components/Templates/MultiSelect.js","images/color_imgs/B.svg","images/color_imgs/R.svg","components/SetDetails/Reset.js","components/Templates/SearchBar.js","components/Templates/CustomCheckbox.js","images/color_imgs/W.svg","images/color_imgs/C.svg","images/color_imgs/M.svg","components/SetDetails/ColorCheckboxes.js","data/findCards.js","components/SetDetails/NumberOwnedDropdown.js","components/SetDetails/BoosterDropdown.js","components/SetDetails/CMCDropdowns.js","images/color_imgs/U.svg","images/color_imgs/G.svg","components/Templates/CustomButton.js","components/SetDetails/RarityButtons.js","components/SetDetails/CardTypeDropdown.js","components/All/CardListImage.js","hooks/useIsCardAddible.js","components/SetDetails/ManualCollectionButtons.js","components/Templates/LazyLoad.js","components/All/CardList.js"],"names":["CustomDropdown","items","labels","firstSelection","selectfn","undefined","ariaLabel","useState","open","setOpen","selected","setSelected","clickItem","item","useEffect","closeOnOutsideClick","document","body","addEventListener","removeEventListener","iconClass","itemsClass","selectedClass","toggleDropdown","event","stopPropagation","index","indexOf","className","tabIndex","onKeyDown","e","key","onClick","role","temp","i","label","push","length","dropdownItems","HoverPreview","children","imgs","height","width","delay","timerID","useRef","current","clearTimeout","locationRef","show","setShow","images","getBoundingClientRect","left","top","documentElement","clientHeight","clientWidth","x","y","getPosition","back","style","src","front","alt","onMouseOver","setTimer","onMouseOut","ref","onFocus","onBlur","onDragStart","createPortal","getElementById","setTimeout","MultiSelect","options","noneSelectedText","useValForSelected","initialSelected","selectedFn","topLabelContents","dropdownOptions","map","option","addOption","selectedOption","text","val","newState","addToSelected","filter","removeFromSelected","chevronClass","dropdownOptionsClass","Reset","value","action","resetDisplayOptions","SearchBar","advanced","term","setTerm","dispatch","useDispatch","initialSearchTerm","useSelector","state","displayOptions","searchTerm","initialSearchType","searchType","timeoutid","setSearchTerm","object","searchTypes","type","placeholder","autoComplete","autoCapitalize","spellCheck","onChange","target","Object","keys","find","setSearchType","CustomCheckbox","labelText","checked","labelClass","inputClass","name","id","htmlFor","ColorCheckboxes","header","colorValues","colors","colorSVGs","W","U","B","R","G","C","M","colorLen","colorRefs","setColorRefs","Array","fill","_","createRef","renderColors","color","title","charAt","toUpperCase","slice","makeKeyboardClickable","onMouseLeave","blur","selectColor","filterSet","cardSet","set","isArray","includes","filterBasicLands","cardTypeLine","excludeBasicLands","filterColor","cardColor","searchColors","multi","white","blue","black","red","green","colorless","entries","symbol","filterRarity","cardRarity","rarity","filterBooster","cardBooster","booster","sortCards","cardList","sort","card1","card2","name1","name2","cmc","filterByTerm","card","advancedSearchType","match","printed_name","type_line","oracle_text","card_faces","face","checkText","filterCMC","cardCMC","selectedCMCs","selectedCMC","filterLegality","deckType","cardLegalities","filterCardTypes","cardTypes","keepCard","cardType","filterCompanions","keywords","filterCommanders","typeline","toLowerCase","findCards","searchOptions","searchCards","arenaCards","cmcs","addType","filterFunctions","color_identity","legalities","addCard","NumberOwnedDropdown","showCards","setShowCards","BoosterDropdown","selectBooster","CMCDropdowns","resetCount","selectCMCS","CustomButton","RarityButtons","rarities","renderRarityButtons","buttonClass","selectRarity","CardTypeDropdown","selectedCardTypes","types","selectCardTypes","CardListImage","cardImages","cardHeader","deckBuilder","flipRef","cardRef","isCardAddible","deckMap","sideboardMap","commander","companion","maxCopies","copiesInDeck","arenaId","copies","useIsCardAddible","imgSide","setImgSide","flipButton","onDragEnd","CardSide","addCardToDeck","addCardToSideboard","changeCommander","setAddType","changeCompanion","setDragCard","flip","animation","setCardModalContent","showCardModal","preventDefault","compose","draggable","ManualCollectionButtons","hovering","setHovering","onMouseEnter","removeCardFromCollection","addCardToCollection","LazyLoad","childHeight","childWidth","gap","buffer","scrollingParent","viewWidthFn","viewHeightFn","parent","window","viewHeight","innerHeight","viewWidth","innerWidth","element","querySelector","offsetHeight","offsetWidth","childrenPerRow","useMemo","Math","floor","numChildrenShown","setNumChildrenShown","ceil","throttleActive","onScrollY","scrollY","scrollTop","numChildrenWeNeedToShow","throttledOnScrollY","throttledFunction","CardList","setId","cardCollection","inventory","cardCount","boosterVal","reduxSets","reduxCardTypes","addBasics","reduxDeckType","cards","rarityOption","setObj","currentPictures","renderCards","returnCards","numOwned","makeCard","circles","circleClass","collector_number","updateImageList"],"mappings":"yKAyGeA,IAzFf,SAAwB,GAAgF,IAA9EC,EAAK,EAALA,MAAM,EAAD,EAAEC,cAAM,IAAC,KAAE,EAAEC,EAAc,EAAdA,eAAe,EAAD,EAAEC,gBAAQ,IAAC,OAAAC,EAAS,MAAEC,iBAAS,IAAC,OAAAD,EAAS,EAC/F,EAAwBE,oBAAS,GAAM,mBAAhCC,EAAI,KAAEC,EAAO,KAGpB,EAAgCF,mBAASJ,GAAe,mBAAjDO,EAAQ,KAAEC,EAAW,KAgB5B,SAASC,EAAUC,GAEfF,EAAYE,GACZJ,GAAQ,GAGJL,GACAA,EAASS,EAEjB,CAtBAC,qBAAU,WACN,SAASC,IACLN,GAAQ,EACZ,CAIA,OAFAO,SAASC,KAAKC,iBAAiB,QAASH,GAEjC,WACHC,SAASC,KAAKE,oBAAoB,QAASJ,EAC/C,CACJ,GAAG,IAsCH,IAAIK,EAAY,oBACZC,EAAa,iCACbC,EAAgB,oCASpB,SAASC,EAAeC,GACpBA,EAAMC,kBACNhB,GAASD,EACb,CATIA,IACAY,EAAY,kBACZC,EAAa,iBACbC,EAAgB,qBAQpB,IAAMI,EAAQzB,EAAM0B,QAAQjB,GAE5B,OACI,sBAAKkB,UAAU,WAAU,UACrB,sBACIA,UAAWN,EAAeO,SAAS,IACnCC,UAAW,SAACC,GAAsB,UAAVA,EAAEC,KAAiBT,EAAeQ,EAAG,EAC7DE,QAAS,SAACF,GAAC,OAAKR,EAAeQ,EAAE,EACjCG,KAAK,SAAS,gBAAe1B,EAAM,aAAYF,EAAU,UAExDJ,EAAOwB,GAASxB,EAAOwB,GAASzB,EAAMyB,GAAM,IAAE,+BAAM,mBAAGE,UAAWR,SAGvE,qBAAKQ,UAAWP,EAAW,SApDnC,WAGI,IAFA,IAAMc,EAAO,GAAG,WAEPC,GACL,IAAMvB,EAAOZ,EAAMmC,GAGbC,EAAQnC,EAAOkC,GAAKlC,EAAOkC,GAAKnC,EAAMmC,GAE5CD,EAAKG,KAAK,qBACNV,UAAU,gBAA2BC,SAAS,IAC9CC,UAAW,SAACC,GAAsB,UAAVA,EAAEC,KAAiBpB,EAAUC,EAAM,EAC3DoB,QAAS,kBAAMrB,EAAUC,EAAK,EAC9BqB,KAAK,SAAQ,SAEZG,GAL8BxB,GAM3B,EAbHuB,EAAE,EAAGA,EAAEnC,EAAMsC,OAAQH,IAAM,EAA3BA,GAgBT,OAAOD,CACX,CAgCqCK,OAGzC,C,2GCxFe,SAASC,EAAa,GAA0D,IAAxDC,EAAQ,EAARA,SAAUC,EAAI,EAAJA,KAAK,EAAD,EAAEC,cAAM,IAAC,MAAG,MAAEC,aAAK,IAAC,SAAM,MAAEC,aAAK,IAAC,MAAG,EAGhFC,EAAUC,iBAAO,MAGvBlC,qBAAU,kBAAM,WACRiC,EAAQE,SACRC,aAAaH,EAAQE,QAE7B,CAAC,GAAE,IAGH,IAAME,EAAcH,mBAGpB,EAAwBzC,oBAAS,GAAM,mBAAhC6C,EAAI,KAAEC,EAAO,KAEhBC,EAAS,KAGb,GAAIH,EAAYF,SAAWN,EAAM,CAG7B,MAAsBQ,EAAYF,QAAQM,wBAAlCC,EAAI,EAAJA,KAAMC,EAAG,EAAHA,IAGd,EAoEJ,SAAqBb,EAAQC,EAAOW,EAAMC,GAGtC,MAAsCzC,SAAS0C,gBAAvCC,EAAY,EAAZA,aAAcC,EAAW,EAAXA,YAGlBC,EAAIL,EAAMM,EAAIL,EAGdD,EAAOX,EAAQe,IACfC,EAAID,EAAcf,EAAQ,GAI1BY,EAAM,EACNK,EAAI,EACGL,EAAMb,EAASe,IACtBG,EAAIH,EAAef,EAAS,GAIhC,MAAO,CAAEiB,IAAGC,IAChB,CA1FqBC,CAAYnB,EAAQD,EAAKqB,KAAa,EAANnB,EAAUA,EAAOW,EAAMC,GAAhEI,EAAC,EAADA,EAAGC,EAAC,EAADA,EAEXR,EACI,sBAAK1B,UAAU,kBAAkBqC,MAAO,CAAET,KAAMK,EAAGJ,IAAKK,GAAI,UACxD,qBAAKI,IAAKvB,EAAKwB,MAAOC,IAAI,uBAAuBxC,UAAU,oBAC1De,EAAKqB,KAAO,qBAAKE,IAAKvB,EAAKqB,KAAOI,IAAI,sBAAsBxC,UAAU,oBAAuB,OAG1G,CAGA,OAAQ,qCACJ,qBACIyC,YAAaC,EAAUC,WAAYA,EAAYtC,QAASqC,EAAUE,IAAKrB,EACvEsB,QAASH,EAAUI,OAAQH,EAAYI,YAAaJ,EACpDzC,UAAW,SAACC,GACM,UAAVA,EAAEC,KACFsC,GAER,EAAE,SAED5B,IAEJU,EAAOwB,uBAActB,EAAQtC,SAAS6D,eAAe,iBAAoB,QAM9E,SAASN,IAGLrB,aAAaH,EAAQE,SACrBF,EAAQE,QAAU,KAGlBI,GAAQ,EACZ,CAKA,SAASiB,IAGLpB,aAAaH,EAAQE,SAGrBI,GAAQ,GAGRN,EAAQE,QAAU6B,YAAW,WAGrB/B,EAAQE,UAGRF,EAAQE,QAAU,KAGlBI,GAAQ,GAEhB,GAAGP,EACP,CA4BJ,C,mFCReiC,IA/Gf,SAAqB,GAAuH,IAArHC,EAAO,EAAPA,QAAQ,EAAD,EAAEC,wBAAgB,MAAG,YAAW,MAAEC,yBAAiB,OAAQ,MAAEC,uBAAe,MAAG,GAAE,MAAEC,kBAAU,WAAG/E,EAAS,EAGnIS,qBAAU,WACN,SAASC,IACLN,GAAQ,EACZ,CAIA,OAFAO,SAASC,KAAKC,iBAAiB,QAASH,GAEjC,WACHC,SAASC,KAAKE,oBAAoB,QAASJ,EAC/C,CACJ,GAAG,IAEH,IAqDIsE,EArDJ,EAAwB9E,oBAAS,GAAM,mBAAhCC,EAAI,KAAEC,EAAO,KACpB,EAAgCF,mBAAS4E,GAAgB,mBAAlDzE,EAAQ,KAAEC,EAAW,KA4BtB2E,EAAkBN,EAAQO,KAAI,SAACC,GACjC,OACI,qBAAK5D,UAAU,eACXK,QAAS,SAACF,GAAQA,EAAEN,kBA5BhC,SAAuB+D,GAEnB,IAGqC,EAHjCC,GAAY,EAEhB,cAC6B/E,GAAQ,IAArC,2BAAuC,CAAC,IAA7BgF,EAAc,QACrB,GAAIA,EAAeC,OAASH,EAAOG,MAAQD,EAAeE,MAAQJ,EAAOI,IAAK,CAC1EH,GAAY,EACZ,KACJ,CACJ,CAEA,+BACA,GAAIA,EAAW,CACX,IAAMI,EAAQ,sBAAOnF,GAAQ,CAAE8E,IAG/B7E,EAAYkF,GACRT,GACAA,EAAWS,EAEnB,CACJ,CAMmDC,CAAcN,EAAQ,EAAE,SAG9DA,EAAOG,MAFHH,EAAOI,IAKxB,IAmBIP,EADoB,IAApB3E,EAAS6B,OACU0C,EAKAvE,EAAS6E,KAAI,SAACC,GAC7B,OACI,yBAAyBvD,QAAS,SAACF,GAAC,OAvBhD,SAA4BP,EAAOgE,GAC/BhE,EAAMC,kBACN,IAAMoE,EAAWnF,EAASqF,QAAO,SAAA9C,GAAO,OAAIA,IAAYuC,CAAM,IAG9D7E,EAAYkF,GACRT,GACAA,EAAWS,EAEnB,CAcqDG,CAAmBjE,EAAGyD,EAAO,EAAC,UAClEN,EAAoBM,EAAOI,IAAMJ,EAAOG,KACzC,mBAAG/D,UAAU,kBAFJ4D,EAAOI,IAK5B,IAIJ,IAAIK,EAAe,oBACfC,EAAuB,UACvB5E,EAAgB,WAQpB,OANId,IACAyF,EAAe,kBACfC,EAAuB,iBACvB5E,EAAgB,mBAIhB,sBAAKM,UAAU,iBAAgB,UAC3B,sBAAKA,UAAWN,EAAeW,QAAS,SAACF,GAAQA,EAAEN,kBAAmBhB,GAASD,EAAM,EAAE,UAClF6E,EACD,mBAAGzD,UAAWqE,OAElB,qBAAKrE,UAAWsE,EAAqB,SAChCZ,MAIjB,C,+BC3He,QAA0B,6B,+BCA1B,QAA0B,6B,+BCAzC,wCAaea,IAPf,WAEI,OACI,cAAC,IAAY,CAACC,MAAM,QAAQC,OAAQC,IAAqB1E,UAFvC,mCAI1B,C,yFCqEe2E,IArEf,SAAmB,GAAkB,IAAD,IAAhBC,gBAAQ,IAAC,GAAI,EAG7B,EAAwBjG,mBAAS,IAAG,mBAA7BkG,EAAI,KAAEC,EAAO,KAGdC,EAAWC,cAGXC,EAAoBC,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAeC,UAAU,IACxEC,EAAoBJ,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAeG,UAAU,IAG9ErG,qBAAU,WACN4F,EAAQG,EACZ,GAAG,CAACA,IAGJ/F,qBAAU,WAGN,IAAMsG,EAAYtC,YAAY,WAC1B6B,EAASU,YAAcZ,GAC3B,GAAG,KAGH,OAAO,kBAAMvD,aAAakE,EAAW,CACzC,GAAG,CAACX,EAAME,IAGV,IAQuBW,EAAQ1B,EARzB2B,EAAc,CAAC,WAAY,KAAM,KAAQ,OAAQ,YAAa,YAAa,YAAa,eAY9F,OACI,sBAAK3F,UAAU,SAAQ,UACnB,uBAEI4F,KAAK,SAASC,YAAY,oBAAoB7F,UAAU,YAGxD8F,aAAa,MAAM,mBAAiB,yBAAyB,aAAW,mBACxE,gBAAc,UAAUC,eAAe,OAAOC,WAAW,QAAQ,gBAAc,QAG/ExB,MAAOK,EAAMoB,SAAW,SAAC9F,GAAC,OAAK2E,EAAQ3E,EAAE+F,OAAO1B,MAAM,IAE1D,wBAAQxE,UAAW4E,EAAW,iBAAmB,uBAAwBvE,QAAS,kBAAMyE,EAAQ,GAAG,EAAC,SAAC,mBAAG9E,UAAU,iBAG9G4E,EACA,cAAC,IAAc,CACXvG,MAAO8H,OAAOC,KAAKT,GAAsDjH,UAAU,qBACnFH,gBAvBOmH,EAuBuBC,EAvBf3B,EAuB4BsB,EAtBhDa,OAAOC,KAAKV,GAAQW,MAAK,SAAAjG,GAAG,OAAIsF,EAAOtF,KAAS4D,CAAG,KAuB9CxF,SA7BhB,SAA0BS,GACtB8F,EAASuB,YAAcX,EAAY1G,IACvC,GA2B2C,qBAFyBqG,IAGnD,OAIrB,C,4GCnEe,SAASiB,EAAe,GAAsE,IAApExC,EAAI,EAAJA,KAAK,EAAD,EAAEyC,iBAAS,IAAC,EAAAzC,EAAI,EAAE0C,EAAO,EAAPA,QAASR,EAAQ,EAARA,SAAUS,EAAU,EAAVA,WAAYC,EAAU,EAAVA,WAE1F,OACI,qCAEI,uBAAOf,KAAK,WAAWgB,KAAM7C,EAAM8C,GAAI9C,EAAM0C,QAASA,EAASR,SAAUA,EAAUjG,UAAW2G,IAG9F,uBAAOG,QAAS/C,EAAM/D,UAAW0G,EAAW,SAAEF,MAG1D,C,YCtBe,G,MAAA,IAA0B,+B,gCCA1B,MAA0B,8BCA1B,MAA0B,8BCiB1B,SAASO,EAAgB,GAAa,IAAXC,EAAM,EAANA,OAGhCjC,EAAWC,cAGXiC,EAAc/B,aAAa,SAAAC,GAAK,OAAIA,EAAMC,eAAe8B,MAAM,IAG/DA,EAAS,CAAC,QAAS,OAAQ,QAAS,MAAO,QAAS,YAAa,SACjEC,EAAY,CAAEC,EAAGC,IAAGC,IAAGC,IAAGC,IAAGC,EAAGC,GAI5BC,EAAWT,EAAOvG,OAExB,EAAkChC,mBAAS,IAAG,mBAAvCiJ,EAAS,KAAEC,EAAY,KAC9B3I,qBAAU,WAEN2I,GAAa,SAAAD,GAAS,OAElBE,MAAMH,GAAUI,OAAOpE,KAAI,SAACqE,EAAGxH,GAAC,OAAKoH,EAAUpH,IAAMyH,qBAAW,GAAC,GAEzE,GAAG,CAACN,IAIR,IAAMO,EAAehB,EAAOvD,KAAK,SAACwE,EAAO3H,GAErC,IAAMhB,EAAYyH,EAAYkB,GAAS,gBAAkB,YAEzD,OACI,qBAAKnI,UAAU,gBAAe,SAC1B,cAACuG,EACG,CACAxC,KAAMoE,EAAmB1B,QAASQ,EAAYkB,GAG9C3B,UAAY,qBACRxG,UAAWR,EAAW8C,IAAK6E,EAAU3G,GAAIgC,IAAI,OAG7C,gBAAe2F,EAAO7H,KAAK,WAAW,eAAc2G,EAAYkB,GAAQlI,SAAS,IACjF,aAAYkI,EAAOvF,IAAMgF,EAAUpH,GAAK4H,MAAOD,EAAME,OAAO,GAAGC,cAAgBH,EAAMI,MAAM,GAC3FrI,UAAY,SAACC,GAAC,OAAKqI,YAAsBrI,EAAGyH,EAAUpH,GAAG,EAGzDiI,aAAe,kBAAMb,EAAUpH,GAAGa,QAAQqH,MAAM,EAChDrI,QAAU,kBAAMuH,EAAUpH,GAAGa,QAAQqH,MAAM,IAI/ChC,WAAW,qBAAqBC,WAAW,gBAG3CV,SAAU,SAAC9F,GAAC,OAAK4E,EAAU4D,YAAYxI,EAAE+F,OAAOU,KAAMzG,EAAE+F,OAAOO,SAAU,GApBvD0B,IAHUA,EA2B5C,IAEA,OAGI,cADA,CACA,OAAKnI,UAAU,WAAU,UACrB,uBAAO8G,QAAQ,QAAQ9G,UAAU,gBAAe,SAAGgH,IACnD,qBAAKhH,UAAU,YAAW,SACrBkI,MAIjB,C,4DC4CC,SAASU,EAAUC,EAASC,GAGzB,SAAIA,IAAQD,GAAaf,MAAMiB,QAAQD,IAAQA,EAAIE,SAASH,GAKhE,CAUA,SAASI,EAAiBC,EAAcC,GAEpC,OAAKA,GAEID,EAAaF,SAAS,WAAYE,EAAaF,SAAS,WAQ5DE,EAAaF,SAAS,WAAYE,EAAaF,SAAS,QAKjE,CASA,SAASI,EAAYC,EAAWC,GAG5B,GAAMA,EAAaC,MAyBd,CAGD,GAAKF,EAAU1I,OAAS,EAGpB,OAAO,EAIX,GAAK2I,EAAaC,SACVD,EAAaE,OAASF,EAAaG,MAASH,EAAaI,OACzDJ,EAAaK,KAASL,EAAaM,OAASN,EAAaO,WAI7D,OAAO,EAMX,IAFA,IAEA,MAA6B1D,OAAO2D,QAFrB,CAAE,MAAU,IAAK,KAAU,IAAK,MAAU,IAAK,IAAU,IAAK,MAAU,MAEpC,eAAE,CAAhD,0BAAOlD,EAAI,KAAEmD,EAAM,KAGpB,GAAKT,EAAa1C,KAAUyC,EAAUL,SAASe,GAG3C,OAAO,CAEf,CAEA,OAAO,CACX,CAvDI,SAAKT,EAAaE,OAASH,EAAUL,SAAS,MACzCM,EAAaG,MAASJ,EAAUL,SAAS,MACzCM,EAAaI,OAASL,EAAUL,SAAS,MACzCM,EAAaK,KAASN,EAAUL,SAAS,MACzCM,EAAaM,OAASP,EAAUL,SAAS,UAOzCM,EAAaO,WAAmC,IAArBR,EAAU1I,OA8ClD,CAQA,SAASqJ,EAAaC,EAAYC,GAG9B,QAAIA,EAAOlB,SAASiB,EAKxB,CAQA,SAASE,EAAcC,EAAaC,GAEhC,OAAID,IAAgBC,CAIxB,CAOA,SAASC,EAAUC,GAGfA,EAASC,MAAM,SAACC,EAAOC,GACnB,IAAMC,EAAQF,EAAM7D,KAAK0B,cACnBsC,EAAQF,EAAM9D,KAAK0B,cAEzB,OAAIqC,EAAQC,GACA,EACRD,EAAQC,EACD,EAEJ,CACX,IAGAL,EAASC,MAAM,SAACC,EAAOC,GACnB,OAAOD,EAAMI,IAAMH,EAAMG,GAC7B,GACJ,CAYC,SAASC,EAAaC,EAAMlG,GAAgC,IAA1BmG,EAAmB,UAAD,6CAAC,KAGlD,GAAKA,EAiCD,OAAQA,GAEJ,IAAK,OAED,SAAKC,EAAMF,EAAKnE,OAAUmE,EAAKG,cAAgBD,EAAMF,EAAKG,eAK9D,IAAK,YAED,QAAKD,EAAMF,EAAKI,WAKpB,IAAK,cAED,GAAIJ,EAAKK,aAAeH,EAAMF,EAAKK,aAC/B,OAAO,EAIX,GAAIL,EAAKM,WAAY,CAEjB,IACkC,EADlC,cACmBN,EAAKM,YAAU,IAAlC,2BAAoC,CAAC,IAA1BC,EAAI,QAEX,GAAKA,EAAKF,aAAeH,EAAMK,EAAKF,aAChC,OAAO,CAEf,CAAC,+BACL,CACA,OAAO,EAGX,QACI,OAAO,MAtEM,CAErB,GAEIH,EAAMF,EAAKnE,OAGXqE,EAAMF,EAAKI,YAGTJ,EAAKK,aAAeH,EAAMF,EAAKK,cAG/BL,EAAKG,cAAgBD,EAAMF,EAAKG,cAElC,OAAO,EAIX,GAAIH,EAAKM,WAAY,CAEjB,IACkC,EADlC,cACmBN,EAAKM,YAAU,IAAlC,2BAAoC,CAAC,IAA1BC,EAAI,QAEX,GAAKA,EAAKF,aAAeH,EAAMK,EAAKF,aAChC,OAAO,CAEf,CAAC,+BACL,CACJ,CA6CA,OAAO,EAGP,SAASH,EAAMM,GACX,OAAOA,EAAUjD,cAAcU,SAASnE,EAAKyD,cACjD,CACJ,CAQA,SAASkD,EAAUC,EAASC,GAAe,IAED,EAFA,cAEZA,GAAY,IAAtC,2BAAwC,CAAC,IAA9BC,EAAW,QAElB,GAAqB,OAAhBA,GACD,GAAKF,GAAW,EACZ,OAAO,OAIX,GAAIE,IAAgBF,EAChB,OAAO,CAGnB,CAAC,+BAED,OAAO,CACX,CAQA,SAASG,EAAeC,EAAUC,GAE9B,MAAkC,UAA7BA,EAAeD,EAIxB,CAQA,SAASE,EAAgB7C,EAAc8C,GACnC,IAEgC,EAF5BC,GAAW,EAAM,cAEED,GAAS,IAAhC,2BAAkC,CAAC,IAAxBE,EAAQ,QACf,GAAKhD,EAAaF,SAASkD,GAAW,CAClCD,GAAW,EACX,KACJ,CACJ,CAAC,+BACD,OAAOA,CACX,CAOA,SAASE,EAAiBC,GACtB,QAAIA,EAASpD,SAAS,YAI1B,CAOA,SAASqD,EAAiBC,GAEtB,UADAA,EAAWA,EAASC,eACPvD,SAAS,eAAkBsD,EAAStD,SAAS,cAAesD,EAAStD,SAAS,gBAI/F,CAEewD,IA9cf,SAAmBC,GAAmD,IAApCC,EAAY,UAAD,6CAACC,IAAYnC,IAAK,UAAD,+CAGlD1B,EAA2H2D,EAA3H3D,IAAKX,EAAsHsE,EAAtHtE,MAAO+B,EAA+GuC,EAA/GvC,OAAQG,EAAuGoC,EAAvGpC,QAASxF,EAA8F4H,EAA9F5H,KAAK,EAAyF4H,EAAxFzB,0BAAkB,IAAC,OAAI,IAAiEyB,EAA/DtD,yBAAiB,IAAC,GAAI,EAAEyD,EAAuCH,EAAvCG,KAAMf,EAAiCY,EAAjCZ,SAAUG,EAAuBS,EAAvBT,UAAWa,EAAYJ,EAAZI,QAOjHC,EAAkB,GAyBxB,GApBgB,cAAZD,GACAC,EAAgBpM,MAAM,SAACqK,GAAI,OAAKoB,EAAiBpB,EAAKqB,SAAS,IAInD,cAAZS,GACAC,EAAgBpM,MAAM,SAACqK,GAAI,OAAKsB,EAAiBtB,EAAKI,UAAU,IAIhErC,GACAgE,EAAgBpM,MAAM,SAACqK,GAAI,OAAKnC,EAAUmC,EAAKjC,IAAKA,EAAI,IAIxDjE,GACAiI,EAAgBpM,MAAM,SAACqK,GAAI,OAAKD,EAAaC,EAAMlG,EAAMmG,EAAmB,IAI5E7C,EAGA,GAAMA,EAAMqB,OAASrB,EAAMsB,MAAQtB,EAAMuB,OAASvB,EAAMwB,KAAOxB,EAAMyB,OAASzB,EAAM0B,WAAa1B,EAAMoB,MAKlG,IAAKpB,EAAMoB,OAASpB,EAAM0B,UAG3B,MAAO,GAGPiD,EAAgBpM,MAAM,SAACqK,GAAI,OAAK3B,EAAY2B,EAAKgC,eAAgB5E,EAAM,GAC3E,MAIA+B,GACA4C,EAAgBpM,MAAM,SAACqK,GAAI,OAAKf,EAAae,EAAKb,OAAQA,EAAO,IAIrE4C,EAAgBpM,MAAM,SAACqK,GAAI,OAAK9B,EAAiB8B,EAAKI,UAAWhC,EAAkB,SAGnE1K,IAAZ4L,GACAyC,EAAgBpM,MAAM,SAACqK,GAAI,OAAKZ,EAAcY,EAAKV,QAASA,EAAQ,IAIpEuC,GACAE,EAAgBpM,MAAM,SAACqK,GAAI,OAAKS,EAAUT,EAAKF,IAAK+B,EAAK,IAIxDf,GACDiB,EAAgBpM,MAAM,SAACqK,GAAI,OAAKa,EAAgBC,EAAUd,EAAKiC,WAAW,IAIzEhB,GACDc,EAAgBpM,MAAM,SAACqK,GAAI,OAAKgB,EAAgBhB,EAAKI,UAAWa,EAAU,IAM9E,IAE8B,EAF1BzB,EAAW,GAAG,cAECmC,GAAW,IAA9B,2BAAgC,CAG5B,IAH6B,IAAtB3B,EAAI,QACPkC,GAAU,EAELzM,EAAE,EAAGA,EAAEsM,EAAgBnM,OAAQH,IAGpC,IAAKsM,EAAgBtM,GAAGuK,GAAO,CAC3BkC,GAAU,EACV,KACJ,CAIAA,GAGA1C,EAAS7J,KAAKqK,EAEtB,CAEA,+BAKA,OAJIP,GACAF,EAAUC,GAGPA,CACX,C,+BC5HA,gDA8Be2C,IAvBf,SAA6B,GAAa,IAAXlG,EAAM,EAANA,OACrBjC,EAAWC,cAGXzG,EAAiB2G,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAe+H,SAAS,IAQ1E,OACI,sBAAKnN,UAAU,sBAAqB,UAChC,gCAASgH,IACT,cAAC,IAAc,CACXtI,UAAU,yBAAyBL,MAVjC,CAAC,WAAY,mBAAoB,uBAAwB,mBAAoB,kBAW/EE,eAAgBA,EAAgBC,SAT5C,SAA6BS,GACzB8F,EAASqI,YAAanO,GAC1B,GAMkEV,KAKtE,C,+BC5BA,gDA0Be8O,IAnBf,SAAyB,GAAa,IAAXrG,EAAM,EAANA,OAEjBjC,EAAWC,cACXzG,EAAiB2G,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAeiF,OAAO,IAExE,OACI,sBAAKrK,UAAU,kBAAiB,UAC5B,gCAASgH,IACT,cAAC,IAAc,CACXtI,UAAU,4CACVL,MAAO,CAAC,iBAAkB,cAAe,mBAEzCE,eAAgBA,EAChBC,SAAU,SAACS,GAAI,OAAK8F,EAASuI,YAAcrO,GAAM,GAF5CV,KAMrB,C,+BCxBA,gDAoCegP,IA7Bf,SAAsB,GAUlB,IAV+B,IAAXvG,EAAM,EAANA,OAEdjC,EAAWC,cAGX4H,EAAO1H,aAAa,SAAAC,GAAK,OAAIA,EAAMC,eAAewH,IAAI,IACtDxM,EAAM8E,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAeoI,UAAU,IAG1DpK,EAAU,GAChB,MAFc,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,MAEP,eAAE,CAArB,IAAMnE,EAAI,KACXmE,EAAQ1C,KAAK,CAACqD,KAAM9E,EAAM+E,IAAK/E,GACnC,CACA,OACI,sBAAKe,UAAU,eAAc,UACzB,gCAAQgH,IACR,qBAAKhH,UAAU,yBAAwB,SACnC,qBAAKA,UAAU,UAAS,SACpB,cAAC,IAAW,CACRoD,QAASA,EAASG,gBAAiBqJ,EACnCpJ,WAAY,SAAC1E,GAAQ,OAAKiG,EAAS0I,YAAW3O,GAAU,EAC9CuE,iBAAiB,OAAtBjD,SAM7B,C,+BClCe,QAA0B,6B,+BCA1B,QAA0B,6B,+BCAzC,4DAWe,SAASsN,EAAa,GAA8C,IAA5CjJ,EAAM,EAANA,OAAQD,EAAK,EAALA,MAAM,EAAD,EAAExE,iBAAS,IAAC,KAAE,MAAE+D,YAAI,IAAC,EAAAS,EAAK,EAGpEO,EAAWC,cAGXpC,EAAMxB,mBAEZ,OACI,wBACIpB,UAAWA,EACX4C,IAAKA,EACLvC,QAAU,WAGN0E,EAASN,EAAOD,IAGhB5B,EAAIvB,QAAQqH,MAChB,EAAG,SAEF3E,GAGb,C,+BCnCA,gDAyCe4J,IA7Bf,SAAuB,GAAW,IAAV3G,EAAM,EAANA,OACd4G,EAAY1I,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAe8E,MAAM,IAG5D2D,EAAsB,GAG5B,IAAK,IAAM3D,KAAU0D,EAAU,CAC3B,IAAIE,EAAW,yCAAqC5D,GAG9C0D,EAAS1D,KACX4D,GAAe,UAGnBD,EAAoBnN,KAAK,cAAC,IAAY,CAAC+D,OAAQsJ,IAAc/N,UAAW8N,EAAatJ,MAAO0F,GAAaA,GAC7G,CAEA,OACI,gCAEI,uBAAOlK,UAAU,cAAa,SAAEgH,IAChC,qBAAKhH,UAAU,WAAU,SACpB6N,MAIjB,C,+BCvCA,gDAgCeG,IAzBf,WAQI,IAPA,IAAMjJ,EAAWC,cAEXiJ,EAAoB/I,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAe4G,SAAS,IACvE5L,EAAM8E,aAAY,SAAAC,GAAK,OAAIA,EAAMC,eAAeoI,UAAU,IAG5DpK,EAAU,GACd,MAFkB,CAAC,WAAW,eAAe,UAAU,UAAU,WAAW,cAAc,QAE9D,eAAE,CAAzB,IAAMwC,EAAI,KACXxC,EAAQ1C,KAAK,CAACqD,KAAM6B,EAAM5B,IAAK4B,GACnC,CAEA,OACI,sBAAK5F,UAAU,YAAW,UACtB,0DACA,cAAC,IAAW,CACZoD,QAASA,EAASC,iBAAiB,YACnCG,WAAY,SAAC0K,GAAK,OAAKnJ,EAASoJ,YAAgBD,GAAO,EACvD3K,gBAAiB0K,GACZ7N,KAIjB,C,kHC+IegO,MA/Jf,SAAuB,GAAiD,IAiBhEC,EAEAhO,EAnBiB0K,EAAI,EAAJA,KAAMjL,EAAK,EAALA,MAAOwO,EAAU,EAAVA,WAAW,EAAD,EAAEC,mBAAW,IAAC,GAAK,EAEzDC,EAAUpN,mBACVqN,EAAUrN,mBACV2D,EAAWC,cAET6H,EAAY3H,aAAY,SAAAC,GAAK,OAAIA,EAAMoJ,WAAW,IAAlD1B,QAEF6B,ECdK,SAA0B3D,GAErC,MAAkE7F,aAAY,SAAAC,GAAK,OAAIA,EAAMoJ,WAAW,IAAhGI,EAAO,EAAPA,QAAS9C,EAAQ,EAARA,SAAU+C,EAAY,EAAZA,aAAcC,EAAS,EAATA,UAAWC,EAAS,EAATA,UAIpD,GAAmB,WAAbjD,GAAsC,YAAbA,GAGO,UAA9Bd,EAAKiC,WAAWnB,GAChB,OAAO,EAKf,IA4BIkD,EA5BAC,EAAe,EAanB,GAVIH,GAAaA,EAAUjI,OAASmE,EAAKnE,MACrCoI,IAIAF,GAAaA,EAAUlI,OAASmE,EAAKnE,MACrCoI,IAICL,EAAQ5D,EAAKnE,MAGd,IAAK,IAAMqI,KAAWN,EAAQ5D,EAAKnE,MAC/BoI,GAAgBL,EAAQ5D,EAAKnE,MAAMqI,GAASC,OAKpD,GAAKN,EAAa7D,EAAKnE,MACnB,IAAK,IAAMqI,KAAWL,EAAa7D,EAAKnE,MACpCoI,GAAgBJ,EAAa7D,EAAKnE,MAAMqI,GAASC,OAKzD,OAAQrD,GACJ,IAAK,QACDkD,EAAY,EACZ,MACJ,IAAK,UACDA,EAAY,IACZ,MACJ,QACIA,EAAY,EAIpB,OAAShE,EAAKnE,MACV,IAAK,oBAGL,IAAK,yBAGL,IAAK,aACDmI,EAAY,IACZ,MACJ,IAAK,gBACDA,EAAY,EAYpB,OALIhE,EAAKI,UAAUnC,SAAS,UAAY+B,EAAKI,UAAUnC,SAAS,UAC5D+F,EAAY,KAIZC,EAAeD,CAKvB,CDtE0BI,CAAiBpE,GAG/BnE,EAA2BmE,EAA3BnE,KAAMyE,EAAqBN,EAArBM,WAAYtK,EAASgK,EAAThK,KAG1B,EAAgCpC,oBAAS,GAAK,mBAAtCyQ,EAAO,KAAEC,EAAU,KAIvBC,EAAa,KACJvM,EAAY,KAAMwM,EAAU,KAGzC,GAAIhB,EACAF,EAAa,cAACmB,EAAQ,CAAClN,IAAKvB,EAAKwB,MAAOqE,KAAMA,IAG9CvG,EAAU,SAACF,GAEP,GAAIuO,EACA,OAAQ7B,GACJ,IAAK,OACD9H,EAAS0K,YAAc1E,IACvB,MACJ,IAAK,YACDhG,EAAS2K,YAAmB3E,IAC5B,MACJ,IAAK,YACDhG,EAAS4K,YAAgB5E,IACzBhG,EAAS6K,YAAW,SACpB,MACJ,IAAK,YACD7K,EAAS8K,YAAgB9E,IACzBhG,EAAS6K,YAAW,SAKpC,EAEA7M,EAAY,WACJ2L,GACA3J,EAAS+K,YAAY/E,EAAM,aAAc,MAEjD,EACAwE,EAAU,WACNxK,EAAS+K,YAAY,MACzB,MAIC,CA6CD,IAIUC,EAAT,SAAcnQ,GAGXA,EAAMC,kBAGNwP,GAAYD,GAIRZ,EAAQnN,QAAQgB,MAAM2N,UADtBZ,EACkC,qBAEA,oBAE1C,EA5DA/O,EAAU,WAGN0E,EAAUkL,YAAoB,CAAEnQ,QAAOsP,aAGvCrK,EAAUmL,aAAc,GAC5B,EAGInP,EAAKqB,MAELkN,EACI,wBACItP,UAAW,qCACXK,QAAS,SAAAF,GAAC,OAAI4P,EAAK5P,EAAE,EACrBD,UAAW,SAAAC,GAEO,UAAVA,EAAEC,KAA6B,UAAVD,EAAEC,MAGvBD,EAAEgQ,iBACFJ,EAAK5P,GAEb,EACA,aAAW,YAAYiI,MAAM,YAAW,SAExC,mBAAGpI,UAAU,YAAY4C,IAAK4L,MAKtCH,EAAa,qCACT,cAACmB,EAAQ,CAAClN,IAAKvB,EAAKwB,MAAOqE,KAAMA,EAAMwB,MAAOiD,EAAW,GAAGzE,KAAM5G,UAAU,YAC5E,cAACwP,EAAQ,CAAClN,IAAKvB,EAAKqB,KAAOwE,KAAMA,EAAMwB,MAAOiD,EAAW,GAAGzE,KAAM5G,UAAU,iBAKhFqO,EAAa,cAACmB,EAAQ,CAAClN,IAAKvB,EAAKwB,MAAOqE,KAAMA,EAAMwB,MAAOxB,GAsBnE,CAGA,IAAMwJ,EAEF,sBAAKpQ,UAAW,gBAAiBC,SAAS,KAAKC,UAAW,SAAAC,GAAC,OAAIqI,YAAsBrI,EAAGsO,EAAQ,EAAC,UAE7F,sBAAKzO,UAAU,gCAA+B,UAEzCsO,EAED,qBACItO,UAAWoP,EAAU,QAAU,gBAAiBxM,IAAK6L,EAASxO,SAAS,IACvEI,QAASA,EAAS0C,YAAaA,EAAawM,UAAWA,EAAU,SAEhElB,OAGRiB,KAKT,OAAIf,EAGI,aADA,CACC1N,EAAA,EAAY,CAACE,KAAMA,EAAK,SACpBqP,IAKNA,CACX,EAKA,SAASZ,EAAS,GAA4C,IAA1ClN,EAAG,EAAHA,IAAKsE,EAAI,EAAJA,KAAK,EAAD,EAAEwB,aAAK,IAAC,OAAI,MAAEpI,iBAAS,IAAC,OAAI,EACrD,OAAO,qBAAKsC,IAAKA,EAAKE,IAAKoE,EAAM,aAAYA,EAAMwB,MAAOA,EAAOpI,UAAWA,EAAWqQ,UAAU,QACrG,C,MEtIeC,MAtCf,SAAiC,GAAqB,IAAnBxP,EAAQ,EAARA,SAAUiK,EAAI,EAAJA,KACnChG,EAAWC,cACjB,EAAkCrG,mBAAS,aAAY,mBAA/C4R,EAAQ,KAAEC,EAAW,KAE7B,OACI,sBACI3J,GAAG,0BACH4J,aAAc,kBAAMD,EAAY,GAAG,EACnC/H,aAAc,kBAAM+H,EAAY,YAAY,EAAC,UAE7C,wBACIxQ,UAAWuQ,EACXlQ,QAAS,kBAAM0E,EAAS2L,YAAyB3F,GAAM,EACvD7K,UAAW,SAACC,GACM,UAAVA,EAAEC,KACFD,EAAEN,iBAEV,EAAE,SAEF,mBAAGG,UAAU,iBAEhBc,EACD,wBACId,UAAWuQ,EACXlQ,QAAS,kBAAM0E,EAAS4L,YAAoB5F,GAAM,EAClD7K,UAAW,SAACC,GACM,UAAVA,EAAEC,KACFD,EAAEN,iBAEV,EAAE,SAEF,mBAAGG,UAAU,kBAK7B,ECyFe4Q,MAjHf,SAAkB,GAGd,IAFA9P,EAAQ,EAARA,SAAU+P,EAAW,EAAXA,YAAaC,EAAU,EAAVA,WAAW,EAAD,EAAEC,WAAG,IAAC,IAAC,MAAEC,cAAM,IAAC,IAAC,MAClDC,uBAAe,IAAC,OAAI,MAAEC,mBAAW,IAAC,OAAI,MAAEC,oBAAY,IAAC,OAAI,EAIrDC,EAASC,OACTC,EAAaF,EAAOG,YACpBC,EAAYJ,EAAOK,WAGvB,GAAIR,EAAiB,CACjB,IAAMS,EAAUtS,SAASuS,cAAcV,GAGnCS,IAIAJ,GADAF,EAASM,GACWE,aACpBJ,EAAYJ,EAAOS,YAE3B,CAGIV,IACAG,EAAaH,EAAaG,IAE1BJ,IACAM,EAAYN,EAAYM,IAI5B,IAAMM,EAAiBC,mBAAQ,WAG3B,OAAOC,KAAKC,OAAQT,EAAYT,IAAQD,EAAaC,GACzD,GAAG,CAACS,EAAWV,EAAYC,IAG3B,EAAgDpS,mBAASqS,EAAOc,GAAe,mBAAxEI,EAAgB,KAAEC,EAAmB,KAGtCnR,EAAUgR,KAAKI,KAAKtR,EAASH,OAAOmR,GAAkBjB,EAGtDwB,EAAiBjR,kBAAO,GA0D9B,OAvDAlC,qBAAU,WAGN,SAASoT,IAEL,IAAMC,EAAUtB,EAAkBG,EAAOoB,UAAYpB,EAAOmB,QAGtDE,EAA0BT,KAAKI,MAAMG,EAAUjB,GAAcT,GAAeiB,EAG9EW,EAA0BzB,EAAOc,EAAiBI,GAClDC,EAAoBM,EAA0BzB,EAAOc,EAE7D,CA8BA,IAAMY,EAAuB,WAAL,OArBLC,EAqByBL,EArBNpR,EAqBiB,SAlB9CmR,EAAehR,UAGhBgR,EAAehR,SAAU,EAGzB6B,YAAW,WAGPmP,EAAehR,SAAU,EAGzBsR,GACJ,GAAGzR,KAhBV,IAAkByR,EAAmBzR,CAqBqB,EAM3D,OAHAkQ,EAAO9R,iBAAiB,SAAUoT,GAG3B,kBAAMtB,EAAO7R,oBAAoB,SAAUmT,EAAoB,CAE1E,GAAG,CAAC1B,EAAQH,EAAaiB,EAAgBI,EAAkBd,EAAQH,EAAiBK,IAIhF,qBAAKtR,UAAU,WAAWqC,MAAO,CAAE,UAAW,UAAMrB,EAAM,OAAO,SAG5DF,EAASyH,MAAM,EAAG2J,IAG/B,E,cCiLeU,IA/Rf,SAAkB,GAAoD,IA8P9D3R,EAAOD,EAAQ+P,EAAKC,EAAQE,EA9PiC,IAAjD2B,aAAK,IAAC,OAAI,MAAE5B,uBAAe,IAAC,OAAI,EAAE1C,EAAW,EAAXA,YAG1CuE,EAAmB5N,aAAY,SAAAC,GAAK,OAAIA,EAAM4N,SAAS,IAAvDD,eAER,EAGI5N,aAAY,SAAAC,GAAK,OAAIA,EAAMC,cAAc,IAFzC8B,EAAM,EAANA,OAAQ7B,EAAU,EAAVA,WAAYE,EAAU,EAAVA,WAAY4H,EAAS,EAATA,UAAW6F,EAAS,EAATA,UAAWpG,EAAI,EAAJA,KAC7CqG,EAAU,EAAnB5I,QAA0B6I,EAAS,EAAdpK,IAA2BqK,EAAc,EAAzBnH,UAAmC4B,EAAQ,EAAhB1D,OAGpE,EAEIhF,aAAY,SAAAC,GAAK,OAAIA,EAAMoJ,WAAW,IADtCI,EAAO,EAAPA,QAASC,EAAY,EAAZA,aAAcC,EAAS,EAATA,UAAWC,EAAS,EAATA,UAAWsE,EAAS,EAATA,UAAqBC,EAAa,EAAvBxH,SAAyBgB,EAAO,EAAPA,QAI/E9H,EAAWC,cAGXsO,EAAQvB,mBAAQ,WAGlB,IAcI1H,EAiBAvB,EA/BAyK,EAAe,GACnB,IAAK,IAAMrJ,KAAU0D,EAGbA,EAAS1D,IACTqJ,EAAa7S,KAAKwJ,GAU1B,QALIqJ,EAAa5S,OAAS,GAAK4S,EAAa5S,OAAS,KACjD4S,OAAe9U,GAIXwU,GACJ,IAAK,cACD5I,GAAU,EACV,MACJ,IAAK,kBACDA,GAAU,EACV,MACJ,IAAK,YACDA,OAAU5L,EAUlB,GAAIoU,EACA/J,EAAM+J,OAMN,GAAyB,IAArBK,EAAUvS,OACVmI,OAAMrK,MAGH,CACHqK,EAAM,GAAG,IACsB,EADtB,cACaoK,GAAS,IAA/B,2BAAiC,CAAC,IAAtBM,EAAM,QACd1K,EAAIpI,KAAK8S,EAAOxP,IACpB,CAAC,+BACL,CAMJ,IAAIgI,OAAYvN,EAEhB,GAAK0U,EAAexS,QAAU,EAAI,CAC9BqL,EAAY,GAAI,IAEqB,EAFrB,cAEOmH,GAAc,IAArC,2BAAuC,CAAC,IAA7BjH,EAAQ,QAEfF,EAAUtL,KAAKwL,EAASlI,IAC5B,CAAC,+BACL,CAGA,IAAI0H,OAAejN,EAEnB,GAAKmO,EAAKjM,QAAU,EAAI,CACpB+K,EAAe,GAAG,IAEK,EAFL,cAECkB,GAAI,IAAvB,2BAAyB,CAAC,IAAd/B,EAAG,QACXa,EAAahL,KAAKmK,EAAI7G,IAC1B,CAAC,+BACL,CAGA,IAAI6H,EAAWwH,EAGV9E,GAAiC,YAAlB8E,GAAiD,WAAlBA,IAC/CxH,OAAWpN,GAIf,IAAIgO,EAAgB,CAChB3D,IAAKA,EAAKX,MAAOjB,EAAQmD,QAASA,EAASH,OAAQqJ,EAAc1O,KAAMQ,EACvE2F,mBAAoBzF,EAAYqH,KAAMlB,EAAcG,SAAUA,EAAUG,UAAWA,GAevF,OAZIuC,IAGI6E,EACA3G,EAAa,2BAAQA,GAAa,IAAEtD,mBAAmB,EAAOyD,UAAMnO,EAAWyL,YAAQzL,EAAWuN,eAAWvN,IAI7GgO,EAAcI,QAAUA,GAIzBL,YAAUC,EAErB,GAAG,CAACwG,EAAYJ,EAAOM,EAAgBvG,EAAMyG,EAAe9E,EAAarH,EAAQ7B,EAAYE,EAAYqI,EAAUsF,EAAWE,EAAWvG,IAGrI4G,EAAkB,GAGhBC,EAAc3B,mBAAQ,WACxB,IACwB,EADpB4B,EAAc,GAAG,cACFL,GAAK,yBAAbvI,EAAI,QAGL6I,EAAWd,EAAe/H,EAAKkE,SAAW6D,EAAe/H,EAAKkE,SAAW,EAG3E4E,GAAW,EAaf,IAVoB,mBAAd1G,GACc,aAAdA,GAAyC,IAAbyG,GACd,qBAAdzG,GAAoCyG,EAAa,GACnC,yBAAdzG,GAAwCyG,EAAa,GACvC,qBAAdzG,GAAiD,IAAbyG,KAEtCC,GAAW,IAITA,EACF,iBAIJJ,EAAgB/S,KAAKqK,EAAKhK,MAG1B,IAAIuN,OAAU,EAGd,GAAKC,EAUA,CAGD,IAAMuF,EAAW,WAIb,IAHA,IAAIvT,EAAO,GAGFC,EAAE,EAAGA,EAAE,EAAGA,IAAK,CAGpB,IAAIuT,EAAc,cAGdvT,GAAKoT,IACLG,GAAe,YAInB,IAAI/E,EAAe,EAGfH,GAAaA,EAAUI,UAAYlE,EAAKkE,SACxCD,IAGAF,GAAaA,EAAUG,UAAYlE,EAAKkE,SACxCD,IAIAL,EAAQ5D,EAAKnE,OAAS+H,EAAQ5D,EAAKnE,MAAMmE,EAAKkE,WAC9CD,GAAgBL,EAAQ5D,EAAKnE,MAAMmE,EAAKkE,SAASC,QAGjDN,EAAa7D,EAAKnE,OAASgI,EAAa7D,EAAKnE,MAAMmE,EAAKkE,WACxDD,GAAgBJ,EAAa7D,EAAKnE,MAAMmE,EAAKkE,SAASC,QAItDF,GAAgBxO,EAAIwO,IACpB+E,GAAe,WAInBxT,EAAKG,KAAK,mBAAGV,UAAW+T,GAAY,aAAYvT,EAAC,YAAIuK,EAAKkE,UAC9D,CACA,OAAO1O,CACX,CA5CiB,GA+CjB+N,EACI,qBAAKtO,UAAU,UAAS,SACpB,qBAAKA,UAAU,sBAAqB,SAC/B8T,KAIjB,MAjEIxF,EACI,cAAC,EAAuB,CAACvD,KAAMA,EAAK,SAChC,sBAAK/K,UAAU,WAAU,cAAI4T,EAAQ,aAkEjDD,EAAYjT,KACR,cAAC,EAAa,CACVqK,KAAMA,EAAMjL,MAAO2T,EAAgB1T,QAAQgL,EAAKhK,MAAOuN,WAAYA,EAAYC,YAAaA,GAEvFxD,EAAKkE,QAAUlE,EAAKkE,QAAO,UAAMlE,EAAKjC,KAAG,OAAGiC,EAAKiJ,mBAE5D,EA1GN,2BAA0B,GA4GzB,+BACD,OAAOL,CAEX,GAAG,CAACb,EAAgBQ,EAAOnG,EAAWoB,EAAaI,EAASC,EAAcC,EAAWC,IAwBrF,OArBA5P,qBAAW,WACP6F,EAASkP,YAAgBR,GAE7B,GAAG,CAACC,IAIAnF,GACAtN,EAAQ,IACRD,EAAS,MACT+P,EAAM,GACNC,EAAS,EACTE,EAAc,SAAAM,GAAS,OAAIA,EAAY,EAAG,IAE1CvQ,EAAQ,IACRD,EAAS,OACT+P,EAAM,GACNC,EAAS,EACTE,EAAc,SAAAM,GAAS,OAAIA,EAAY,EAAG,GAGtC,qCAEFjD,EAEK,KAFS,oBAAG1H,GAAG,wBAAuB,wBAC9B,sBAAM7G,UAAU,gBAAe,SAAEgT,IAAiB,eAIjE,qBAAKhT,UAAU,iBAAgB,SAC3B,cAAC,EAAQ,CACL8Q,WAAY7P,EAAO4P,YAAa7P,EAAQ+P,IAAKA,EAAKC,OAAQA,EAC1DC,gBAAiBA,EAAiBC,YAAaA,EAAY,SAE1DwC,QAIjB,C","file":"static/js/0.578e251a.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\r\n\r\nimport '../../css/CustomDropdown.css';\r\n\r\n/**\r\n * Creates a dropdown menu where the selected item is displayed\r\n * @prop {Array} items An array of strings that are the different options that can be selected\r\n * @prop {Array} labels An array corresponding with items. items determines the value passed to the selectfn, while\r\n * labels determines what text is shown in the dropdown, if that label is defined. Only the specific labels that should\r\n * be overwritten need to be defined.\r\n * @example (with only one overwritten label): const labels = []; labels[4] = \"historic brawl\";\r\n * @prop {String} firstSelection The string of the default selection. Should be one of the strings in the items array.\r\n * @prop {Function} [selectfn=undefined] An additional callback function that uses the item selected as an argument.\r\n * @prop {String} [ariaLabel=undefined] An aria-label.\r\n * @returns Custom dropdown JSX.\r\n */\r\nfunction CustomDropdown({ items, labels=[], firstSelection, selectfn=undefined, ariaLabel=undefined }) {\r\n    const [open, setOpen] = useState(false);\r\n\r\n    // In some cases keeping track of selected might be redundant\r\n    const [selected, setSelected] = useState(firstSelection);\r\n    \r\n    // Close Dropdown on all clicks outside of dropdown\r\n    useEffect(() => {   \r\n        function closeOnOutsideClick() {\r\n            setOpen(false);\r\n        }\r\n        \r\n        document.body.addEventListener('click', closeOnOutsideClick);\r\n\r\n        return () => {\r\n            document.body.removeEventListener('click', closeOnOutsideClick);\r\n        }\r\n    }, []);\r\n\r\n    // Helper function for clicking an item in the dropdown\r\n    function clickItem(item) {\r\n\r\n        setSelected(item);\r\n        setOpen(false);\r\n\r\n        // Some Uses of dropdown may have additional things to do when selecting an option (like dispatch redux)\r\n        if (selectfn) {\r\n            selectfn(item);\r\n        }\r\n    }\r\n\r\n    // Map the Items\r\n    function dropdownItems() {\r\n        const temp = [];\r\n\r\n        for (let i=0; i<items.length; i++) {\r\n            const item = items[i];\r\n\r\n            // The displayed label may be different from the item\r\n            const label = labels[i] ? labels[i] : items[i];\r\n\r\n            temp.push(<div \r\n                className='dropdown-item' key={item} tabIndex='0' \r\n                onKeyDown={(e) => { if (e.key === 'Enter') clickItem(item) }} \r\n                onClick={() => clickItem(item)}\r\n                role='button' \r\n            >\r\n                {label}\r\n            </div>);\r\n        }\r\n\r\n        return temp;\r\n    }\r\n\r\n    // Closed dropdown classes\r\n    let iconClass = 'icon chevron down';\r\n    let itemsClass = 'dropdown-items dropdown-closed';\r\n    let selectedClass = 'dropdown-selected dropdown-closed'\r\n\r\n    // Change classes if dropdown is open\r\n    if (open) {\r\n        iconClass = 'icon chevron up';\r\n        itemsClass = 'dropdown-items';\r\n        selectedClass = 'dropdown-selected';\r\n    }\r\n\r\n    function toggleDropdown(event) {\r\n        event.stopPropagation();\r\n        setOpen(!open);\r\n    }\r\n\r\n    const index = items.indexOf(selected);\r\n\r\n    return (\r\n        <div className=\"dropdown\">\r\n            <div\r\n                className={selectedClass} tabIndex='0' \r\n                onKeyDown={(e) => { if (e.key === 'Enter') toggleDropdown(e) }} \r\n                onClick={(e) => toggleDropdown(e)}\r\n                role='button' aria-expanded={open} aria-label={ariaLabel}\r\n            >\r\n                {labels[index] ? labels[index] : items[index]} <span><i className={iconClass}/></span>\r\n\r\n            </div>\r\n            <div className={itemsClass}>{dropdownItems()}</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CustomDropdown;\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport { createPortal } from 'react-dom';\r\n\r\nimport '../../css/HoverPreview.css'\r\n\r\n/**\r\n * Wrap HoverPreview around JSX to create a hover preview. Returns the children wrapped in a div that's used\r\n * to determine the location of the JSX as well as add onClick, onMouseOver, and onMouseLeave events. Also creates\r\n * a portal to \"#hoverPreview\" to display the preview.\r\n * @prop {object} imgs An object of images to display. Requires imgs.front to contain an <img>, with imgs.back \r\n * to optionally display a second <img> tag next to it. Both images assumed to be same size.\r\n * @prop {number} [height=350] Optional height of image(s).\r\n * @prop {number} [width=247.07] Optional width of a SINGLE image. (Automatically doubled when imgs.back exists)\r\n * @prop {number} [delay=500] Optional parameter to set the delay time in ms.\r\n */\r\nexport default function HoverPreview({ children, imgs, height=350, width=247.07, delay=500 }) {\r\n\r\n    // Stores current timer when it exists\r\n    const timerID = useRef(null);\r\n    \r\n    // Cancel timers on unmount\r\n    useEffect(() => () => {\r\n        if (timerID.current) {\r\n            clearTimeout(timerID.current);\r\n        }\r\n    }, []);\r\n    \r\n    // Location of div wrapped around the children, used to determine hover preview location\r\n    const locationRef = useRef();\r\n\r\n    // Track whether to show this hover preview\r\n    const [show, setShow] = useState(false);\r\n\r\n    let images = null;\r\n    \r\n    // Add hover preview when locationRef is fully initialized\r\n    if (locationRef.current && imgs) {\r\n\r\n        // (x,y) coordinates of top, left corner\r\n        const { left, top } = locationRef.current.getBoundingClientRect();\r\n\r\n        // Will store the final (x,y) coordinates for the hover preview\r\n        const { x, y } = getPosition(height, imgs.back ? width*2 : width, left, top); // Double width if imgs.back\r\n        \r\n        images = (\r\n            <div className=\"hoverPreviewDiv\" style={{ left: x, top: y }}>\r\n                <img src={imgs.front} alt=\"hoverPreviewFrontImg\" className=\"hoverPreviewImg\" />\r\n                {imgs.back ? <img src={imgs.back}  alt=\"hoverPreviewBackImg\" className=\"hoverPreviewImg\" /> : null}\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    // Wrap children in a div to easily reference location\r\n    return (<>\r\n        <div\r\n            onMouseOver={setTimer} onMouseOut={onMouseOut} onClick={setTimer} ref={locationRef}\r\n            onFocus={setTimer} onBlur={onMouseOut} onDragStart={onMouseOut} \r\n            onKeyDown={(e) => {\r\n                if (e.key === \"Enter\") {\r\n                    setTimer();\r\n                }\r\n            }}\r\n        >\r\n            {children}\r\n        </div>\r\n        {show ? createPortal( images, document.getElementById(\"hoverPreview\") ) : null}\r\n    </>);\r\n\r\n    /**\r\n     * Cancels any active or pending hover preview when the mouse leaves this target.\r\n     */\r\n    function onMouseOut() {\r\n\r\n        // Clear the timer when the mouse leaves the target\r\n        clearTimeout(timerID.current);\r\n        timerID.current = null;\r\n\r\n        // Forcefully stop the hover preview on mouse leave\r\n        setShow(false);\r\n    }\r\n\r\n    /**\r\n     * Forcefully sets timer\r\n     */\r\n    function setTimer() {\r\n\r\n        // Clear any active timer\r\n        clearTimeout(timerID.current);\r\n\r\n        // Hide hover preview until timer is complete\r\n        setShow(false);\r\n\r\n        // Set a delay before showing the hover preview\r\n        timerID.current = setTimeout(() => {\r\n            \r\n            // Check if timer is still valid\r\n            if (timerID.current) {\r\n\r\n                // Clear timers\r\n                timerID.current = null;\r\n\r\n                // Show the hover preview once the coordinates are set\r\n                setShow(true);\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * Gets the x and y coordinates to place the preview at\r\n     */\r\n    function getPosition(height, width, left, top) {\r\n\r\n        // Get screen height and width\r\n        const { clientHeight, clientWidth } = document.documentElement;\r\n\r\n        // Default position at upper left corner of target\r\n        let x = left, y = top;\r\n\r\n        // Shift image left if off screen to the right\r\n        if (left + width > clientWidth) {\r\n            x = clientWidth - width - 1;\r\n        }\r\n\r\n        // Shift image up or down if off screen vertically\r\n        if (top < 0) {\r\n            y = 0;\r\n        } else if (top + height > clientHeight) {\r\n            y = clientHeight - height - 1;\r\n        }\r\n\r\n        // Set coordinates for the hover preview after ensuring the preview will be on-screen\r\n        return { x, y };\r\n    }\r\n}","import React, { useState, useEffect } from 'react';\r\n\r\nimport '../../css/MultiSelect.css';\r\n\r\n/**\r\n * A dropdown that allows for multiple selections\r\n * \r\n * @prop {Array} options An Array of the options that can be selected. Each option is an object that has text and val as keys\r\n * @prop {String} [noneSelectedText='Select...'] String to show when nothing is currently selected. Defaults to \"Select...\"\r\n * @prop {Boolean} [useValForSelected=false] A boolean that determines whether to use the val to represent the rendered button when that option selected. False by default\r\n * @prop {Array} [initialSelected=[]] Initially selected options. If using state management (eg redux), set this value to that state.\r\n * @prop {Function} [selectedFn=undefined] A function to run when the selected options change.\r\n * @returns JSX for multiselectable dropdown\r\n */\r\nfunction MultiSelect({ options, noneSelectedText = 'Select...', useValForSelected = false, initialSelected = [], selectedFn = undefined }) {\r\n\r\n    // Close Dropdown on all clicks outside of dropdown\r\n    useEffect(() => {\r\n        function closeOnOutsideClick() {\r\n            setOpen(false);\r\n        }\r\n\r\n        document.body.addEventListener('click', closeOnOutsideClick);\r\n\r\n        return () => {\r\n            document.body.removeEventListener('click', closeOnOutsideClick);\r\n        }\r\n    }, []);\r\n\r\n    const [open, setOpen] = useState(false);\r\n    const [selected, setSelected] = useState(initialSelected);\r\n\r\n    // Helper function to add an option to selected if is not there already\r\n    function addToSelected(option) {\r\n        // initialize add to selected to be true\r\n        let addOption = true;\r\n\r\n        // Check each option currently selected and see if the option to be added is already selected\r\n        for (const selectedOption of selected) {\r\n            if (selectedOption.text === option.text && selectedOption.val === option.val) {\r\n                addOption = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If the option passed and wasn't already selected --> Add it \r\n        if (addOption) {\r\n            const newState = [...selected, option];\r\n\r\n            // Update local state and use extra function if provided\r\n            setSelected(newState);\r\n            if (selectedFn) {\r\n                selectedFn(newState);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Map all of the options with add function\r\n    const dropdownOptions = options.map((option) => {\r\n        return (\r\n            <div className=\"multi-option\"\r\n                onClick={(e) => { e.stopPropagation(); addToSelected(option) }}\r\n                key={option.val}\r\n            >\r\n                {option.text}\r\n            </div>\r\n        );\r\n    });\r\n\r\n    // Helper function to remove an option from selected\r\n    function removeFromSelected(event, option) {\r\n        event.stopPropagation();\r\n        const newState = selected.filter(current => current !== option);\r\n\r\n        // Update local state and use extra function if provided\r\n        setSelected(newState);\r\n        if (selectedFn) {\r\n            selectedFn(newState);\r\n        }\r\n    }\r\n\r\n    // Initialize top-level multiselect contents\r\n    let topLabelContents;\r\n\r\n    // If nothing is selected, render \"Select...\" or provided text\r\n    if (selected.length === 0) {\r\n        topLabelContents = noneSelectedText;\r\n    }\r\n\r\n    // Else map all selected options and render them\r\n    else {\r\n        topLabelContents = selected.map((option) => {\r\n            return (\r\n                <button key={option.val} onClick={(e) => removeFromSelected(e, option)}>\r\n                    {useValForSelected ? option.val : option.text}\r\n                    <i className=\"delete icon\"></i>\r\n                </button>\r\n            );\r\n        });\r\n    }\r\n\r\n    // Class definitions that change if dropdown is open\r\n    let chevronClass = \"icon chevron down\";\r\n    let dropdownOptionsClass = \"options\";\r\n    let selectedClass = \"selected\";\r\n\r\n    if (open) {\r\n        chevronClass = \"icon chevron up\";\r\n        dropdownOptionsClass = \"options active\";\r\n        selectedClass = \"selected active\";\r\n    }\r\n\r\n    return (\r\n        <div className=\"multi-dropdown\">\r\n            <div className={selectedClass} onClick={(e) => { e.stopPropagation(); setOpen(!open) }}>\r\n                {topLabelContents}\r\n                <i className={chevronClass}></i>\r\n            </div>\r\n            <div className={dropdownOptionsClass}>\r\n                {dropdownOptions}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default MultiSelect;\r\n","export default __webpack_public_path__ + \"static/media/B.7f78a23f.svg\";","export default __webpack_public_path__ + \"static/media/R.b8e69eab.svg\";","import React from 'react';\r\n\r\nimport Custombutton from '../Templates/CustomButton';\r\nimport { resetDisplayOptions } from '../../actions';\r\nimport '../../css/Reset.css';\r\n\r\nfunction Reset() {\r\n    const resetBtnClass = 'ui button positive reset-button';\r\n    return(\r\n        <Custombutton value=\"Reset\" action={resetDisplayOptions} className={resetBtnClass} />\r\n    )\r\n}\r\n\r\nexport default Reset;","import React, { useState, useEffect } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport { setSearchTerm, setSearchType } from '../../actions';\r\nimport CustomDropdown from './CustomDropdown';\r\nimport '../../css/SearchBar.css';\r\n\r\n/**\r\n * Updates redux state with searchTerm from search bar input\r\n * @returns Search bar JSX\r\n */\r\nfunction SearchBar({advanced=true}) {\r\n    \r\n    // Track current search term for controlled input\r\n    const [term, setTerm] = useState(\"\");\r\n\r\n    // Get access to dispatch\r\n    const dispatch = useDispatch();\r\n\r\n    // Get initial search term from redux\r\n    const initialSearchTerm = useSelector(state => state.displayOptions.searchTerm);\r\n    const initialSearchType = useSelector(state => state.displayOptions.searchType);\r\n\r\n    // Update initial Search Term and Type on first load\r\n    useEffect(() => {\r\n        setTerm(initialSearchTerm);\r\n    }, [initialSearchTerm]);\r\n\r\n    // Track change in search bar (debounced)\r\n    useEffect(() => {\r\n\r\n        // Wait for user to stop typing\r\n        const timeoutid = setTimeout( () => {\r\n            dispatch(setSearchTerm(term));\r\n        }, 500);\r\n\r\n        // Cleanup function to stop search\r\n        return () => clearTimeout(timeoutid);\r\n    }, [term, dispatch]);\r\n\r\n    // Search types object: keys are strings to be displayed to user, values are redux values to be used in findCards search\r\n    const searchTypes = {\"All Text\": null, \"Name\": \"name\", \"Type Line\": \"type_line\", \"Card Text\": 'oracle_text'};\r\n    \r\n    // Function that is put into dropdown to select a search term and update redux\r\n    function searchTypeSelect(item) {\r\n        dispatch(setSearchType(searchTypes[item]));\r\n    }\r\n    \r\n    // Function that returns the key that the corresponding value is attributed to\r\n    function getKeyByValue(object, val) {\r\n        return Object.keys(object).find(key => object[key] === val);\r\n    }\r\n\r\n    return (\r\n        <div className=\"search\">\r\n            <input\r\n                // Data\r\n                type=\"search\" placeholder=\"Search Card Text:\" className=\"searchBar\"\r\n\r\n                // Accessibility\r\n                autoComplete=\"off\" aria-describedby=\"searchKeyboardControls\" aria-label=\"Search Card Text\"\r\n                aria-controls=\"results\" autoCapitalize=\"none\" spellCheck=\"false\" aria-haspopup=\"false\"\r\n                \r\n                // Controlled input\r\n                value={term} onChange={ (e) => setTerm(e.target.value) }\r\n            />\r\n            <button className={advanced ? \"clearSearchBar\" : \"clearSearchBarSimple\"} onClick={() => setTerm(\"\")}><i className=\"close icon\"/></button>\r\n            \r\n            { // Determine whether to show advanced search\r\n                advanced ? \r\n                <CustomDropdown \r\n                    items={Object.keys(searchTypes)} key={`SearchType ${initialSearchType}`} ariaLabel=\"Select Search Type\"\r\n                    firstSelection={getKeyByValue(searchTypes, initialSearchType)} \r\n                    selectfn={searchTypeSelect}\r\n                /> : null\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SearchBar;","import React from 'react';\r\n\r\n/**\r\n * A custom checkbox\r\n * @param {string} props.text Text for the checkbox\r\n * @param {boolean} props.checked True/false the checkbox is checked\r\n * @param {function} props.onChange Function to execute on checkbox change\r\n * @param {string} props.labelClass Class name(s) for the label\r\n * @param {string} props.inputClass Class name(s) for the input\r\n * @returns Checkbox JSX\r\n */\r\nexport default function CustomCheckbox({ text, labelText=text, checked, onChange, labelClass, inputClass }) {\r\n\r\n    return (\r\n        <>\r\n            {/* Checkbox input */}\r\n            <input type=\"checkbox\" name={text} id={text} checked={checked} onChange={onChange} className={inputClass}/>\r\n            \r\n            {/* Checkbox Label */}\r\n            <label htmlFor={text} className={labelClass}>{labelText}</label>\r\n        </>\r\n    );\r\n}","export default __webpack_public_path__ + \"static/media/W.99c7fe1b.svg\";","export default __webpack_public_path__ + \"static/media/C.4af949b5.svg\";","export default __webpack_public_path__ + \"static/media/M.fb91d492.svg\";","import React, { createRef, useEffect, useState } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport { selectColor } from '../../actions';\r\nimport CustomCheckbox from '../Templates/CustomCheckbox';\r\nimport makeKeyboardClickable from '../../hooks/makeKeyboardClickable';\r\nimport '../../css/ColorCheckboxes.css';\r\n\r\n// Import SVG images\r\nimport W from '../../images/color_imgs/W.svg';\r\nimport U from '../../images/color_imgs/U.svg';\r\nimport B from '../../images/color_imgs/B.svg';\r\nimport R from '../../images/color_imgs/R.svg';\r\nimport G from '../../images/color_imgs/G.svg';\r\nimport C from '../../images/color_imgs/C.svg';\r\nimport M from '../../images/color_imgs/M.svg';\r\n\r\nexport default function ColorCheckboxes({ header }) {\r\n\r\n    // Access the redux dispatcher\r\n    const dispatch = useDispatch();\r\n\r\n    // Get currently selected colors from redux state\r\n    const colorValues = useSelector( state => state.displayOptions.colors );\r\n\r\n    // List card colors and the tags needed for their icons\r\n    const colors = ['white', 'blue', 'black', 'red', 'green', 'colorless', 'multi'];\r\n    const colorSVGs = [ W, U, B, R, G, C, M ];\r\n    \r\n    /* REALLY CONVOLUTED WAY TO MAKE ELEMENTS FROM MAP KEYBOARD ACCESSIBLE */\r\n        // Need to keep track of length of colors array, because references depend on it\r\n        const colorLen = colors.length;\r\n        // Use state to rerender component upon change\r\n        const [colorRefs, setColorRefs] = useState([]);\r\n        useEffect(() => {\r\n            // Set state to keep track of refs to each color checkbox\r\n            setColorRefs(colorRefs => (\r\n                // Fill colorRefs array - keeping current ref if it exists, otherwise make a new one\r\n                Array(colorLen).fill().map((_, i) => colorRefs[i] || createRef())\r\n            ));\r\n        }, [colorLen]);\r\n    /* End convoluted keyboard accessibility stuff */\r\n\r\n    // Create color checkboxes for each\r\n    const renderColors = colors.map( (color, i) => {\r\n\r\n        const iconClass = colorValues[color] ? \"big colorIcon\" : \"colorIcon\";\r\n\r\n        return (\r\n            <div className=\"colorCheckbox\" key={color}>\r\n                <CustomCheckbox\r\n                    // Data\r\n                    text={color} key={color} checked={colorValues[color]}\r\n    \r\n                    // Icon\r\n                    labelText={ <img\r\n                        className={iconClass} src={colorSVGs[i]} alt=\"icon\"\r\n\r\n                        // Keyboard accessibility\r\n                        aria-controls={color} role=\"checkbox\" aria-checked={colorValues[color]} tabIndex=\"0\"\r\n                        aria-label={color} ref={ colorRefs[i] } title={color.charAt(0).toUpperCase() + color.slice(1)}\r\n                        onKeyDown={ (e) => makeKeyboardClickable(e, colorRefs[i])}\r\n\r\n                        // Blur when hover ends and blur when deselected\r\n                        onMouseLeave={ () => colorRefs[i].current.blur() }\r\n                        onClick={ () => colorRefs[i].current.blur() }\r\n                    /> }\r\n    \r\n                    // Classes\r\n                    labelClass=\"colorBoxInputLabel\" inputClass=\"colorBoxInput\"\r\n    \r\n                    // Dispatch redux action\r\n                    onChange={(e) => dispatch( selectColor(e.target.name, e.target.checked) )}\r\n                />\r\n            </div>\r\n        );\r\n    });\r\n\r\n    return (\r\n        \r\n        // Checkboxes for color: White, Blue, Black, Red, Green, All Multicolored, Colorless\r\n        <div className=\"colorBox\">\r\n            <label htmlFor=\"color\" className=\"colorBoxLabel\">{ header }</label>\r\n            <div className=\"colorList\">\r\n                {renderColors}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n","import arenaCards from \"./arenaCards\";\r\n\r\n//  const allArenaCards = require('./arenaCards20210719155815.json')\r\n/**\r\n * \r\n * @param {*} searchOptions Object of options to filter the cards on Arena. Define as an object eg{set:'setId', name:'cardName', color: ['W', 'G'] \r\n * (color also accepts 'colorless' or 'multi'), rarity: ['rarity1','rarity2'], booster: boolean}\r\n * @param {*} returnOptions An Array of addtional properties to retrieve eg ['image_uris', 'set', 'cmc', etc]\r\n * @param {} searchCards Optional. A List of card objects to search. Defaults to all cards on arena.\r\n * @param {boolean} sort Optional. Boolean to sort the found cards. Defaults to true.\r\n * @returns An array of the cards found\r\n */\r\nfunction findCards(searchOptions, searchCards=arenaCards, sort=true) {\r\n\r\n    // Destructure search options\r\n    const { set, color, rarity, booster, term, advancedSearchType=null, excludeBasicLands=true, cmcs, deckType, cardTypes, addType } = searchOptions;\r\n\r\n    /**\r\n     * An array of ananymous functions to be called on each card\r\n     * - Each function must take ONLY the card as a parameter.\r\n     * @param {Object} card The card to be tested.\r\n     */\r\n    const filterFunctions = [];\r\n\r\n/* DETERMINE WHICH FUNCTIONS NEED TO BE CALLED ON EACH CARD */\r\n\r\n    // Only show Companions if requested\r\n    if (addType === \"companion\") {\r\n        filterFunctions.push( (card) => filterCompanions(card.keywords));\r\n    }\r\n\r\n    // Only show Commanders if requested\r\n    if (addType === \"commander\") {\r\n        filterFunctions.push( (card) => filterCommanders(card.type_line));\r\n    }\r\n\r\n    // Filter by set if needed\r\n    if (set) {\r\n        filterFunctions.push( (card) => filterSet(card.set, set) );\r\n    }\r\n\r\n    // Filter by name if needed\r\n    if (term) {\r\n        filterFunctions.push( (card) => filterByTerm(card, term, advancedSearchType) );\r\n    }\r\n\r\n    // Filter by color if needed\r\n    if (color) {\r\n\r\n        // If all colors are false, don't filter by color\r\n        if (!(color.white || color.blue || color.black || color.red || color.green || color.colorless || color.multi)) {\r\n            // Don't add function\r\n\r\n        }\r\n        // If multi AND colorless are selected, 0 cards returned from findCards function\r\n        else if ( color.multi && color.colorless ) {\r\n            \r\n            // Exit filterFunction definition and return empty array\r\n            return [];\r\n\r\n        } else {\r\n            filterFunctions.push( (card) => filterColor(card.color_identity, color) );\r\n        }\r\n    }\r\n\r\n    // Filter by rarity if needed\r\n    if (rarity) {\r\n        filterFunctions.push( (card) => filterRarity(card.rarity, rarity) );\r\n    }\r\n\r\n    // Filter Out Basic Lands OR only show basic lands\r\n    filterFunctions.push( (card) => filterBasicLands(card.type_line, excludeBasicLands) );\r\n\r\n    // Filter booster if needed\r\n    if (booster !== undefined) {\r\n        filterFunctions.push( (card) => filterBooster(card.booster, booster) );\r\n    }\r\n\r\n    // Filter cmc if needed\r\n    if (cmcs) {      \r\n        filterFunctions.push( (card) => filterCMC(card.cmc, cmcs) );\r\n    }\r\n\r\n    // Filter Card legality if needed\r\n    if ( deckType ) {\r\n        filterFunctions.push( (card) => filterLegality( deckType, card.legalities));\r\n    }\r\n\r\n    // Filter Card Types if needed\r\n    if ( cardTypes ) {\r\n        filterFunctions.push( (card) => filterCardTypes(card.type_line, cardTypes));\r\n    }\r\n\r\n/* Call each chosen filter function on each card */\r\n\r\n    // Card list will hold chosen cards\r\n    let cardList = [];\r\n\r\n    for (const card of searchCards) { // Loop over cards\r\n        let addCard = true;\r\n\r\n        for (let i=0; i<filterFunctions.length; i++) { // Loop over filter functions\r\n\r\n            // Call filter function on card and stop calling filter functions if one returns false\r\n            if (!filterFunctions[i](card)) {\r\n                addCard = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Decide whether to add card to card list\r\n        if (addCard) {\r\n\r\n            // Push card with desired properties to card list\r\n            cardList.push(card);\r\n        }\r\n    }\r\n\r\n    // Sort the cards \r\n    if (sort) {\r\n        sortCards(cardList);\r\n    }\r\n\r\n    return cardList;\r\n}\r\n\r\n/**\r\n * Filter cards not in specified set.\r\n * @param {String} cardSet Set code of the card\r\n * @param {any} set Either a string that is the desired Set or an array of the desired 3 letter set codes\r\n * @returns True if cardSet and set match or if cardSet is included in array, false otherwise.\r\n */\r\n function filterSet(cardSet, set) {\r\n\r\n    // Filter cards not in the set\r\n    if (set === cardSet || ( Array.isArray(set) && set.includes(cardSet) )) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * We either wnat to filter out basic lands from our search or only show basic lands\r\n * Filters out Basic Lands if excludeBasicLands is true.\r\n * If excludeBasicLands is false. Will filter out anything that is NOT a basic land.\r\n * @param {String} cardTypeLine The type line of the card to check\r\n * @param {boolean} excludeBasicLands True to filter out basic lands, false to filter out cards that are NOT basic lands\r\n * @returns Returns true if the card should be included in findCards array, false if it shouldn't\r\n */\r\nfunction filterBasicLands(cardTypeLine, excludeBasicLands) {\r\n\r\n    if ( excludeBasicLands ) {\r\n        // Skip basic lands\r\n        if ( cardTypeLine.includes('Basic') && cardTypeLine.includes('Land') ){\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    // excludeBasicLands === false\r\n    // The same code as above but the return boolean is flipped\r\n    if ( cardTypeLine.includes('Basic') && cardTypeLine.includes('Land') ){\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\n/**\r\n * Filter by Color helper function\r\n * @param {Array} cardColor Array of strings containing the color identities of the card to be checked.\r\n * @param {Object} searchColors Object containing the boolean values for the desired colors.\r\n * @returns True if the card colors match the search colors (logic is more complex for multi and colorless).\r\n * Returns false if the card colors don't match.\r\n */\r\nfunction filterColor(cardColor, searchColors) {\r\n        \r\n    // Multi false logic\r\n    if ( !searchColors.multi ) {\r\n\r\n        // If the card contains any of the WUBRG colors that are being searched for\r\n        if ((searchColors.white && cardColor.includes('W')) ||\r\n            (searchColors.blue  && cardColor.includes('U')) ||\r\n            (searchColors.black && cardColor.includes('B')) ||\r\n            (searchColors.red   && cardColor.includes('R')) ||\r\n            (searchColors.green && cardColor.includes('G')))\r\n        {\r\n            // Card matches a color\r\n            return true;\r\n        }\r\n\r\n        // Check if colorless is true and the card is colorless\r\n        if ( searchColors.colorless && (cardColor.length === 0) ) {\r\n\r\n            // Card matches colorless\r\n            return true;\r\n        }\r\n\r\n        // No multi-color match found\r\n        return false;\r\n    }\r\n\r\n    // Multi true\r\n    else {\r\n\r\n        // Check if card has more than one color in color identity\r\n        if ( cardColor.length < 2 ) {\r\n\r\n            // Card isn't multi-color\r\n            return false;\r\n        }\r\n        \r\n        // Check if multi is the only color option that is true\r\n        if ( searchColors.multi && \r\n             !( searchColors.white || searchColors.blue  || searchColors.black || \r\n                searchColors.red   || searchColors.green || searchColors.colorless )\r\n           )\r\n        {\r\n            // Card is multi-color\r\n            return true;\r\n        }\r\n\r\n        // Card must include ALL required colors but may include addtional colors\r\n        const colors = { 'white' : 'W', 'blue'  : 'U', 'black' : 'B', 'red'   : 'R', 'green' : 'G' };\r\n        \r\n        for (const [name, symbol] of Object.entries(colors)) {\r\n            \r\n            // Make sure card has all required colors\r\n            if ( searchColors[name] && !cardColor.includes(symbol) ) {\r\n\r\n                // Card doesn't include a required color\r\n                return false;\r\n            } \r\n        }\r\n        // Card includes all required colors\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Check if the card's rarity is in the rarity array\r\n * @param {String} cardRarity The rarity of the card to be checked.\r\n * @param {Array} rarity The array of desired rarities.\r\n * @returns True when the card's rarity is in the rarities array.\r\n */\r\nfunction filterRarity(cardRarity, rarity) {\r\n\r\n    // Check if the rarity array contains the rarity of the card\r\n    if (rarity.includes(cardRarity)) {\r\n        return true;\r\n    }\r\n    return false;\r\n        \r\n}\r\n\r\n/**\r\n * Checks if the card's booster value and the desired booster value match\r\n * @param {boolean} cardBooster The card's booster value\r\n * @param {boolean} booster The desired booster value.\r\n * @returns True if the desired value for booster and the card's booster value match.\r\n */\r\nfunction filterBooster(cardBooster, booster) {\r\n\r\n    if (cardBooster === booster) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Sorts a list of MTG Arena cards \r\n * @param {Array} cardList The array containing the cards to be sorted.\r\n * @returns An array of cards sorted by converted mana cost, then alphabetically within each cmc group.\r\n */\r\nfunction sortCards(cardList) {\r\n\r\n    // First sorts alphabetically\r\n    cardList.sort( (card1, card2) => {\r\n        const name1 = card1.name.toUpperCase(); // ignore upper and lowercase\r\n        const name2 = card2.name.toUpperCase();\r\n\r\n        if (name1 < name2)\r\n            return -1\r\n        if (name1 > name2)\r\n            return 1\r\n        // Names are equal\r\n        return 0\r\n    });\r\n\r\n    // Then by cmc\r\n    cardList.sort( (card1, card2) => {\r\n        return card1.cmc - card2.cmc\r\n    })\r\n}\r\n\r\n/**\r\n * Searches card for specified search term (includes partial matches).\r\n * - If advancedSearchType is specified, an advanced search is performed.\r\n * - An advanced search searches only the card section specified by the string in advancedSearchType.\r\n * @param {Object} card Card object to search. Only uses name, type_line, oracle_text, and card_faces properties.\r\n * @param {string} term The search term to match.\r\n * @param {string} advancedSearchType Regular search if unspecified. If specified, creates an advanced search.\r\n * \"name\", \"type_line\", and \"oracle_text\" are the allowed advanced search types, indicating the specific card section to search.\r\n * @returns True if the card contains the search term, false otherwise. (Or matches advanced search options if specified)\r\n */\r\n function filterByTerm(card, term, advancedSearchType=null) {\r\n\r\n    // Normal search\r\n    if (!advancedSearchType) {\r\n\r\n        if (\r\n            // Check name\r\n            match(card.name) ||\r\n    \r\n            // Check type line\r\n            match(card.type_line) ||\r\n        \r\n            // Check oracle text if it exists\r\n            ( card.oracle_text && match(card.oracle_text) ) ||\r\n\r\n            // Check printed_name if it exists\r\n            ( card.printed_name && match(card.printed_name) )\r\n        ) {\r\n            return true;\r\n        }\r\n    \r\n        // Need to check card faces in order to find some cards\r\n        if (card.card_faces) {\r\n    \r\n            // Check for oracle_text match on either face\r\n            for (const face of card.card_faces) {\r\n    \r\n                if ( face.oracle_text && match(face.oracle_text) ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Advanced search\r\n    else {\r\n        switch (advancedSearchType) {\r\n\r\n            case \"name\":\r\n                // Check name only\r\n                if ( match(card.name) || (card.printed_name && match(card.printed_name))) {\r\n                    return true;\r\n                }\r\n                return false;\r\n\r\n            case \"type_line\":\r\n                // Check type line only\r\n                if ( match(card.type_line) ) {\r\n                    return true;\r\n                }\r\n                return false;\r\n\r\n            case \"oracle_text\": {\r\n                // Check oracle text\r\n                if (card.oracle_text && match(card.oracle_text)) {\r\n                    return true;\r\n                }\r\n\r\n                // Need to check card faces in order to find some cards\r\n                if (card.card_faces) {\r\n            \r\n                    // Check for oracle_text match on either face\r\n                    for (const face of card.card_faces) {\r\n            \r\n                        if ( face.oracle_text && match(face.oracle_text) ) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    // False if no match found above\r\n    return false;\r\n\r\n    // Helper function to make comparing the search term less verbose. Compares input to search term\r\n    function match(checkText) {\r\n        return checkText.toUpperCase().includes(term.toUpperCase());\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if a card should be kept in the finalCards array based on the cmc of the card and selected CMCs\r\n * @param {Number} cardCMC The converted mana cost of card\r\n * @param {*} selectedCMCs Array of values of cmcs to be accepted. \r\n * @returns Returns true if the card should be kept. False if not\r\n */\r\nfunction filterCMC(cardCMC, selectedCMCs) {\r\n\r\n    for (const selectedCMC of selectedCMCs) {\r\n        // Check if the value is '8+'\r\n        if ( selectedCMC === '8+' ) {\r\n            if ( cardCMC >= 8 ) {\r\n                return true;\r\n            }\r\n\r\n        } else {\r\n            if (selectedCMC === cardCMC){\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if a card is legal in the format given\r\n * @param {string} deckType The desired decktype format to check.\r\n * @param {object} cardLegalities The legalities object of the card to check\r\n * @returns {boolean} Returns true if the card should be kept. False if not\r\n */\r\nfunction filterLegality(deckType, cardLegalities) {\r\n    // Check the card legality of the given decktype\r\n    if ( cardLegalities[deckType] === 'legal'){\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if the card is a wanted type. \r\n * @param {string} cardTypeLine The type_line of the individual card to be checked.\r\n * @param {*} cardTypes Array of card types to keep\r\n * @returns Returns true if the card should be kept. False if not\r\n */\r\nfunction filterCardTypes(cardTypeLine, cardTypes) {\r\n    let keepCard = false // Initialize return boolean to false;\r\n\r\n    for (const cardType of cardTypes) {\r\n        if ( cardTypeLine.includes(cardType)) {\r\n            keepCard = true;\r\n            break;\r\n        }\r\n    }\r\n    return keepCard\r\n}\r\n\r\n/**\r\n * Determines whether this card is a companion.\r\n * @param {array} keywords The key words for the card. Will contain \"Companion\" if this card is a companion.\r\n * @returns True if the card is a Companion.\r\n */\r\nfunction filterCompanions(keywords) {\r\n    if (keywords.includes(\"Companion\")) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines whether this card is a commander.\r\n * @param {string} typeline The type line for the card. Will contain \"Legendary\" + (\"Creature\" OR \"Planeswalker\") if valid.\r\n * @returns True if the card is a Commander.\r\n */\r\nfunction filterCommanders(typeline) {\r\n    typeline = typeline.toLowerCase();\r\n    if (typeline.includes(\"legendary\") && ( typeline.includes(\"creature\") || typeline.includes(\"planeswalker\") )) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport default findCards;\r\n","import React from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport CustomDropdown from '../Templates/CustomDropdown';\r\nimport { setShowCards } from '../../actions';\r\nimport '../../css/NumberOwnedDropdown.css';\r\n\r\nfunction NumberOwnedDropdown({ header }) {\r\n    const dispatch = useDispatch();\r\n\r\n    // Need to check redux for first Selection in cases where something else changes the state of the dropdown (eg reset button)\r\n    const firstSelection = useSelector(state => state.displayOptions.showCards);\r\n\r\n    const items = ['Own None', 'Own at Least One', 'Missing at Least One', 'Own Full Playset', 'Show All Cards'];\r\n\r\n    function selectfnNumberOwned(item) {\r\n        dispatch(setShowCards(item))\r\n    }\r\n\r\n    return (\r\n        <div className=\"numberOwnedDropdown\">\r\n            <label>{ header }</label>\r\n            <CustomDropdown \r\n                ariaLabel=\"Filter by Number Owned\" items={items} key={firstSelection} \r\n                firstSelection={firstSelection} selectfn={selectfnNumberOwned} \r\n            />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default NumberOwnedDropdown;","import React from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport CustomDropdown from '../Templates/CustomDropdown';\r\nimport { selectBooster }  from '../../actions/index';\r\nimport '../../css/BoosterDropdown.css';\r\n\r\nfunction BoosterDropdown({ header }) {\r\n\r\n    const dispatch = useDispatch();\r\n    const firstSelection = useSelector(state => state.displayOptions.booster);\r\n\r\n    return (\r\n        <div className=\"boosterDropdown\">\r\n            <label>{ header }</label>\r\n            <CustomDropdown \r\n                ariaLabel=\"Filter Cards by Booster Pack Availability\"\r\n                items={['Show All Cards', 'In Boosters', 'Not In Boosters']}\r\n                key={firstSelection} \r\n                firstSelection={firstSelection}\r\n                selectfn={(item) => dispatch(selectBooster(item))}\r\n            />\r\n        </div>        \r\n    )\r\n}\r\n\r\nexport default BoosterDropdown;\r\n","import React from 'react';\r\nimport { useDispatch, useSelector} from 'react-redux';\r\n\r\nimport MultiSelect from '../Templates/MultiSelect';\r\nimport { selectCMCS } from '../../actions';\r\nimport '../../css/CMCDropdowns.css';\r\n\r\nfunction CMCDropdowns({ header }) {\r\n\r\n    const dispatch = useDispatch();\r\n\r\n    // Get the current selections from redux\r\n    const cmcs = useSelector( state => state.displayOptions.cmcs);\r\n    const key = useSelector(state => state.displayOptions.resetCount);\r\n\r\n    const items = [0,1,2,3,4,5,6,7,'8+'];\r\n    const options = [];\r\n    for (const item of items) {\r\n        options.push({text: item, val: item});\r\n    } \r\n    return (\r\n        <div className=\"CMCDropdowns\">\r\n            <label>{header}</label> \r\n            <div className=\"CMCDropdowns-container\">\r\n                <div className=\"pickCMC\">\r\n                    <MultiSelect \r\n                        options={options} initialSelected={cmcs} \r\n                        selectedFn={(selected) => dispatch(selectCMCS(selected))}\r\n                        key={key} noneSelectedText='All'\r\n                    />\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CMCDropdowns;","export default __webpack_public_path__ + \"static/media/U.8fcc549b.svg\";","export default __webpack_public_path__ + \"static/media/G.1e9be629.svg\";","import React, { useRef } from 'react';\r\nimport { useDispatch } from 'react-redux';\r\n\r\n/**\r\n * A custom React-Redux button.\r\n * @param {function} action The raw action to dispatch.\r\n * @param {any} value The value to be dispatched.\r\n * @param {string} className Class name(s) to be applied to the button. Equal to \"\" if not specified.\r\n * @param {string} text The button text. Equal to value if not specified.\r\n * @returns Button JSX\r\n */\r\nexport default function CustomButton({ action, value, className=\"\", text=value }) {\r\n\r\n    // Access redux reducer\r\n    const dispatch = useDispatch();\r\n\r\n    // Add a ref to blur button\r\n    const ref = useRef();\r\n\r\n    return (\r\n        <button \r\n            className={className}\r\n            ref={ref}\r\n            onClick={ () => {\r\n\r\n                // Dispatch the action\r\n                dispatch(action(value));\r\n\r\n                // Deselect the button\r\n                ref.current.blur();\r\n            } }\r\n        >\r\n            {text}\r\n        </button>\r\n    );\r\n}","import React from 'react';\r\nimport { useSelector } from 'react-redux';\r\n\r\nimport { selectRarity } from '../../actions';\r\nimport CustomButton from '../Templates/CustomButton';\r\nimport '../../css/RarityButtons.css';\r\n\r\n/**\r\n * The rarity buttons selecter for card filtering. \r\n * @param {String} props.header The string for the label of the Rarity buttons\r\n * @returns JSX for rarity buttons\r\n */\r\nfunction RarityButtons({header}) {\r\n    const rarities  = useSelector(state => state.displayOptions.rarity);\r\n    \r\n    // Create array of rarity buttons\r\n    const renderRarityButtons = [];\r\n\r\n    // Loop through each rarity and check whether it's currently selected\r\n    for (const rarity in rarities) {\r\n        let buttonClass = `ui button primary rarityButton ${rarity}`;\r\n\r\n        // If the rarity isn't currently selected, add \"basic\" to its class\r\n        if ( !rarities[rarity] )\r\n            buttonClass += ' basic';\r\n        \r\n        // Then push that rarity button to the array\r\n        renderRarityButtons.push(<CustomButton action={selectRarity} className={buttonClass} value={rarity} key={rarity} />);\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            {/* Buttons that select rarity: Mythic, Rare, Uncommon, Common */}\r\n            <label className=\"rarityLabel\">{header}</label>\r\n            <div className=\"showList\">\r\n                {renderRarityButtons}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default RarityButtons;","import React from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport MultiSelect from '../Templates/MultiSelect';\r\nimport { selectCardTypes } from '../../actions';\r\nimport '../../css/CardTypeDropdown.css';\r\n\r\nfunction CardTypeDropdown() {\r\n    const dispatch = useDispatch();\r\n\r\n    const selectedCardTypes = useSelector(state => state.displayOptions.cardTypes);\r\n    const key = useSelector(state => state.displayOptions.resetCount);\r\n\r\n    const cardTypes = ['Creature','Planeswalker','Instant','Sorcery','Artifact','Enchantment','Land'];\r\n    let options = [];\r\n    for (const type of cardTypes) {\r\n        options.push({text: type, val: type})\r\n    }\r\n\r\n    return (\r\n        <div className=\"cardTypes\">\r\n            <label > Select Card Type(s):</label>\r\n            <MultiSelect \r\n            options={options} noneSelectedText=\"All Types\"\r\n            selectedFn={(types) => dispatch(selectCardTypes(types))}\r\n            initialSelected={selectedCardTypes}\r\n            key={key}\r\n            />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CardTypeDropdown;","import React, { useState, useRef } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport HoverPreview from '../Templates/HoverPreview';\r\nimport {\r\n    setCardModalContent, showCardModal, addCardToDeck, addCardToSideboard, changeCommander, changeCompanion, setAddType, setDragCard\r\n} from '../../actions';\r\nimport makeKeyboardClickable from '../../hooks/makeKeyboardClickable';\r\nimport useIsCardAddible from '../../hooks/useIsCardAddible';\r\nimport '../../css/CardListImage.css';\r\n\r\n/**\r\n * Describes a single image from the CardList, including its backside if applicable.\r\n */\r\nfunction CardListImage({ card, index, cardHeader, deckBuilder=false }) {\r\n    \r\n    const flipRef = useRef();\r\n    const cardRef = useRef();\r\n    const dispatch = useDispatch();\r\n    \r\n    const { addType } = useSelector(state => state.deckBuilder);\r\n\r\n    const isCardAddible = useIsCardAddible(card);\r\n    \r\n    // Destructure card properties for ease of access\r\n    const { name, card_faces, imgs } = card;\r\n    \r\n    // Track image side to be shown (front=true)\r\n    const [ imgSide, setImgSide ] = useState(true);\r\n    \r\n    // Variables that differ between the set view and the deck builder\r\n    let cardImages;\r\n    let flipButton = null; // Regular cards don't have a flip button\r\n    let onClick, onDragStart=null, onDragEnd=null;\r\n\r\n    /* Deck Builder */\r\n    if (deckBuilder) {\r\n        cardImages = <CardSide src={imgs.front} name={name} />; // No title because of hover preview\r\n\r\n        // Clicking will move the card from the card list to the desired portion of the deck\r\n        onClick = (e) => {\r\n\r\n            if (isCardAddible) {\r\n                switch (addType) {\r\n                    case \"deck\":\r\n                        dispatch(addCardToDeck(card));\r\n                        break;\r\n                    case \"sideboard\":\r\n                        dispatch(addCardToSideboard(card));\r\n                        break;\r\n                    case \"commander\":\r\n                        dispatch(changeCommander(card));\r\n                        dispatch(setAddType(\"deck\"));\r\n                        break;\r\n                    case \"companion\":\r\n                        dispatch(changeCompanion(card));\r\n                        dispatch(setAddType(\"deck\"));\r\n                        break;\r\n                    default: break;\r\n                }\r\n            }\r\n        }\r\n\r\n        onDragStart=() => {\r\n            if (isCardAddible) {\r\n                dispatch(setDragCard(card, 'collection', null));\r\n            }\r\n        }\r\n        onDragEnd=() => {\r\n            dispatch(setDragCard(null));\r\n        }\r\n    }\r\n    \r\n    /* Set View */\r\n    else {\r\n\r\n        // Clicking opens a modal to a larger view of the card\r\n        onClick = () => {\r\n            \r\n            // Get the index of the image on click\r\n            dispatch( setCardModalContent({ index, imgSide }) );\r\n            \r\n            // Then show the modal\r\n            dispatch( showCardModal(true) );\r\n        }\r\n\r\n        // Show flip button for 2-sided cards\r\n        if (imgs.back) {\r\n\r\n            flipButton = (\r\n                <button\r\n                    className={'circular ui icon button flipButton'}\r\n                    onClick={e => flip(e)}\r\n                    onKeyDown={e => {\r\n                        // If they hit enter\r\n                        if (e.key === \"Enter\" || e.key === \"Space\") {\r\n\r\n                            // Enter and space shouldn't do their default actions, just flip the card\r\n                            e.preventDefault();\r\n                            flip(e);\r\n                        }\r\n                    }}\r\n                    aria-label=\"Flip Card\" title=\"Flip Card\"\r\n                >\r\n                    <i className=\"undo icon\" ref={flipRef}/>\r\n                </button>\r\n            );\r\n\r\n            // Separate/create front and back cards\r\n            cardImages = <>\r\n                <CardSide src={imgs.front} name={name} title={card_faces[0].name} className=\"cardImg\"/>\r\n                <CardSide src={imgs.back}  name={name} title={card_faces[1].name} className=\"backside\"/>\r\n            </>;\r\n        }\r\n        // No back, so only make one img tag\r\n        else {\r\n            cardImages = <CardSide src={imgs.front} name={name} title={name}/>; // Includes title\r\n        }\r\n\r\n        /**\r\n         * Flips card and turns flip button\r\n         * @param {Event} event \r\n         */\r\n         function flip(event) {\r\n    \r\n            // Don't allow flip button click to propagate onto card\r\n            event.stopPropagation();\r\n            \r\n            // Set state for card side displayed\r\n            setImgSide(!imgSide);\r\n    \r\n            // Animate flip button\r\n            if (imgSide) {\r\n                flipRef.current.style.animation = \"rotate1 .6s linear\";\r\n            } else {\r\n                flipRef.current.style.animation = \"rotate2 .6s linear\";\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Putting all the pieces together except the hover preview for the deck builder\r\n    const compose = (\r\n\r\n        <div className={\"bouncy column\"} tabIndex=\"-1\" onKeyDown={e => makeKeyboardClickable(e, cardRef)}>\r\n\r\n            <div className=\"ui fluid card removeBoxShadow\">\r\n\r\n                {cardHeader}\r\n\r\n                <div \r\n                    className={imgSide ? \"image\" : \"flipped image\"} ref={cardRef} tabIndex=\"0\"\r\n                    onClick={onClick} onDragStart={onDragStart} onDragEnd={onDragEnd}\r\n                >\r\n                    {cardImages}\r\n                </div>\r\n            </div>\r\n            {flipButton}\r\n        </div>\r\n    );\r\n\r\n    // Return the card images wrapped in the hover preview if in deckbuilder\r\n    if (deckBuilder) {\r\n        return (\r\n            // Show preview when hovering\r\n            <HoverPreview imgs={imgs} >\r\n                {compose}\r\n            </HoverPreview>\r\n        );\r\n    }\r\n    // Other wise just return card images\r\n    return compose;\r\n}\r\n\r\nexport default CardListImage;\r\n\r\n/** Helper Component - makes defining card images simpler */\r\nfunction CardSide({ src, name, title=null, className=null }) {\r\n    return <img src={src} alt={name} aria-label={name} title={title} className={className} draggable='true' />;\r\n}\r\n","import { useSelector } from \"react-redux\";\r\n\r\n/**\r\n * A function that checks if a card is able to be added to a deck.\r\n * Checks if there are max copies of a card already in the decklist as well as if the card is legal in the desired deckType.\r\n * @param {object} card The card Object attempting to be added. Should contain at least name, type_line, and  legalities.\r\n * @returns {boolean} True if card can be added. False if it cannot be added\r\n */\r\nexport default function useIsCardAddible(card) {\r\n\r\n    const { deckMap, deckType, sideboardMap, commander, companion } = useSelector(state => state.deckBuilder);\r\n\r\n    // First check if the card is legal in the desired deckType\r\n    // For Custom and Limited, all cards are legal so skip this step\r\n    if (!(deckType === 'custom' || deckType === 'limited')) {\r\n\r\n        // If not legal in Format return false\r\n        if (card.legalities[deckType] !== 'legal'){\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Count the number of copies of the card already in deck\r\n    let copiesInDeck = 0; // Initialize\r\n\r\n    // Check the commander slot\r\n    if (commander && commander.name === card.name) {\r\n        copiesInDeck++;\r\n    }\r\n\r\n    // Check the companion slot\r\n    if (companion && companion.name === card.name) {\r\n        copiesInDeck++;\r\n    }\r\n    \r\n    // Check if the deck has any copies of the card\r\n    if ( deckMap[card.name] ) {\r\n\r\n        // Add up all versions of the card with the same name \r\n        for (const arenaId in deckMap[card.name]) {\r\n            copiesInDeck += deckMap[card.name][arenaId].copies;\r\n        }\r\n    }\r\n\r\n    // Check the sideboard\r\n    if ( sideboardMap[card.name] ) {\r\n        for (const arenaId in sideboardMap[card.name]) {\r\n            copiesInDeck += sideboardMap[card.name][arenaId].copies;\r\n        }\r\n    }\r\n    // Get the max number of copies allowed in a deck for this decktype\r\n    let maxCopies; \r\n    switch (deckType) {\r\n        case 'brawl':\r\n            maxCopies = 1;\r\n            break;\r\n        case 'limited':\r\n            maxCopies = 250; // Really it is unlimited but Arena has a total deck size limit of 250;\r\n            break;\r\n        default:\r\n            maxCopies = 4;\r\n            break;\r\n    }\r\n    // Some cards have special rules for how many are allowed in a deck, those exceptions will need to be explicit\r\n    switch ( card.name ) {\r\n        case \"Dragon's Approach\":\r\n            maxCopies = 250;\r\n            break;\r\n        case \"Persistent Petitioners\":\r\n            maxCopies = 250;\r\n            break;\r\n        case \"Rat Colony\":\r\n            maxCopies = 250;\r\n            break;\r\n        case \"Seven Dwarves\":\r\n            maxCopies = 7;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Decks can have any number of basic lands\r\n    if (card.type_line.includes('Basic') && card.type_line.includes('Land')) {\r\n        maxCopies = 250;\r\n    }\r\n\r\n    // If number of copies currently in deck < max copies allowed --> return true, Otherwise false\r\n    if (copiesInDeck < maxCopies) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","import React, { useState } from \"react\";\r\nimport { useDispatch } from \"react-redux\";\r\n\r\nimport { addCardToCollection, removeCardFromCollection } from \"../../actions\";\r\nimport '../../css/ManualCollectionButtons.css';\r\n\r\nfunction ManualCollectionButtons({ children, card }) {\r\n    const dispatch = useDispatch();\r\n    const [ hovering, setHovering ] = useState(\"invisible\");\r\n\r\n    return (\r\n        <div \r\n            id=\"ManualCollectionButtons\"\r\n            onMouseEnter={() => setHovering(\"\")}\r\n            onMouseLeave={() => setHovering(\"invisible\")}\r\n        >\r\n            <button\r\n                className={hovering}\r\n                onClick={() => dispatch(removeCardFromCollection(card))}\r\n                onKeyDown={(e) => {\r\n                    if (e.key === \"Enter\") {\r\n                        e.stopPropagation();\r\n                    }\r\n                }}\r\n            >\r\n                <i className=\"minus icon\"></i>\r\n            </button>\r\n            {children}\r\n            <button\r\n                className={hovering}\r\n                onClick={() => dispatch(addCardToCollection(card))}\r\n                onKeyDown={(e) => {\r\n                    if (e.key === \"Enter\") {\r\n                        e.stopPropagation();\r\n                    }\r\n                }}\r\n            >\r\n                <i className=\"plus icon\"></i>\r\n            </button>\r\n        </div>\r\n    );\r\n    \r\n}\r\n\r\nexport default ManualCollectionButtons;\r\n","import React, { useState, useEffect, useRef, useMemo } from 'react';\r\n\r\n/**\r\n * Wrap around children to stop them from being rendered to the DOM until they are within about one 'view height' + buffer\r\n * of the parent element. Assumes that all child elements are the same size for calculating when to show them.\r\n * \r\n * @prop {number} childHeight Height of child elements, including margin/padding.\r\n * @prop {number} childWidth Width of child elements, including margin/padding.\r\n * @prop {number} [gap=0] (Optional) Gap between child elements (in a flexbox).\r\n * @prop {number} [buffer=2] Number of rows of cards to load beyond the current screen.\r\n * @prop {string} [scrollingParent=null] (Optional) Specify this string if the element that scrolls is not the window.\r\n * Input to document.querySelector() that selects the scrolling parent of LazyLoad.\r\n * @prop {function} [viewWidthFn=null] (Optional) A transformation to apply to the calculation of the view width. View width\r\n * is initially the offsetWidth of the parent or window.innerWidth if scrollingParent is unspecified.\r\n * @prop {function} [viewHeightFn=null] (Optional) A transformation to apply to the calculation of the view height. View height\r\n * is initially the offsetHeight of the parent or window.innerHeight if scrollingParent is unspecified.\r\n * @returns React.Component that should be wrapped around children that will be lazily loaded.\r\n */\r\nfunction LazyLoad({ \r\n    children, childHeight, childWidth, gap=0, buffer=2, \r\n    scrollingParent=null, viewWidthFn=null, viewHeightFn=null\r\n}) {\r\n\r\n    // Get parent element\r\n    let parent = window;\r\n    let viewHeight = parent.innerHeight;\r\n    let viewWidth = parent.innerWidth;\r\n\r\n    // Check if a parent element other than the window is specified\r\n    if (scrollingParent) {\r\n        const element = document.querySelector(scrollingParent);\r\n\r\n        // Make sure the query string returned something\r\n        if (element) {\r\n\r\n            // Then update parent and call specific height/width properties\r\n            parent = element;\r\n            viewHeight = parent.offsetHeight;\r\n            viewWidth = parent.offsetWidth;\r\n        }\r\n    }\r\n\r\n    // Apply transformations to height and width if applicable\r\n    if (viewHeightFn) {\r\n        viewHeight = viewHeightFn(viewHeight);\r\n    }\r\n    if (viewWidthFn) {\r\n        viewWidth = viewWidthFn(viewWidth);\r\n    }\r\n\r\n    // Calculate the number of children that can fit in a row\r\n    const childrenPerRow = useMemo(() => {\r\n\r\n        // From: NumberChildren * ChildWidth + (NumberChildren - 1) * GapWidth <= ParentWidth\r\n        return Math.floor( (viewWidth + gap) / (childWidth + gap) );\r\n    }, [viewWidth, childWidth, gap]);\r\n\r\n    // Track number of children currently shown\r\n    const [numChildrenShown, setNumChildrenShown] = useState(buffer*childrenPerRow);\r\n\r\n    // Calculate container height to set so scrollbar is about the right size\r\n    const height =  Math.ceil(children.length/childrenPerRow) * childHeight;\r\n\r\n    // Track whether the throttle function is currently active\r\n    const throttleActive = useRef(false); // throttleActive.current = false;\r\n\r\n    // Add listener for Y scrolling on page load or resize\r\n    useEffect(() => {\r\n        \r\n        // Watch for scrolling and compute number of children to show\r\n        function onScrollY() { // Function to throttle\r\n\r\n            const scrollY = scrollingParent ? parent.scrollTop : parent.scrollY;\r\n\r\n            // Calculate number of children to show\r\n            const numChildrenWeNeedToShow = Math.ceil((scrollY + viewHeight) / childHeight) * childrenPerRow;\r\n\r\n            // Increment number of children to show if user scrolls down\r\n            if (numChildrenWeNeedToShow + buffer*childrenPerRow > numChildrenShown) {\r\n                setNumChildrenShown(numChildrenWeNeedToShow + buffer*childrenPerRow);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Allows the \"throttledFunction\" to be run, at most, every \"delay\" milliseconds.\r\n         * Ignores susequent calls to \"throttledFunction\" within the delay period.\r\n         * \r\n         * @param {function} throttledFunction Function to throttle\r\n         * @param {number} delay Number of milliseconds to throttle \"throttledFunction\"\r\n         */\r\n         function throttle(throttledFunction, delay) {\r\n\r\n            // Only accept new function call when throttle is not active\r\n            if (!throttleActive.current) {\r\n\r\n                // Set throttle to active state\r\n                throttleActive.current = true;\r\n\r\n                // After \"delay\" milliseconds, run the throttledFunction and clear \"active\" status of throttle\r\n                setTimeout(() => {\r\n\r\n                    // Clear the active status of throttle\r\n                    throttleActive.current = false;\r\n\r\n                    // Run the throttled function\r\n                    throttledFunction();\r\n                }, delay);\r\n            }\r\n        }\r\n\r\n        // Throttle onScrollY so it's only called, at most, every 200ms\r\n        const throttledOnScrollY = ( () => throttle(onScrollY, 200) );\r\n\r\n        // Track scrolling\r\n        parent.addEventListener(\"scroll\", throttledOnScrollY);\r\n        \r\n        // Cleanup\r\n        return () => parent.removeEventListener(\"scroll\", throttledOnScrollY);\r\n\r\n    }, [buffer, childHeight, childrenPerRow, numChildrenShown, parent, scrollingParent, viewHeight]);\r\n\r\n    // Set height of lazyload div so scroll bar shows true length\r\n    return (\r\n        <div className=\"lazyLoad\" style={{ \"minHeight\" : `${height}px` }} >\r\n\r\n            {/* Only show children if they've been scrolled to */ }\r\n            {children.slice(0, numChildrenShown)}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default LazyLoad;\r\n","import React, { useEffect, useMemo } from 'react';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\n\r\nimport CardListImage from './CardListImage';\r\nimport ManualCollectionButtons from '../SetDetails/ManualCollectionButtons';\r\nimport LazyLoad from '../Templates/LazyLoad';\r\nimport findCards from '../../data/findCards';\r\nimport { updateImageList } from '../../actions';\r\nimport '../../css/CardList.css';\r\n\r\n/**\r\n * The list of MTG Arena cards.\r\n * \r\n * @param {string} [setId=null] (Optional) three letter set code. Can also specify using redux.\r\n * @param {string} [scrollingParent=null] (Optional) Specify this string if the element that scrolls is not the window.\r\n * Input to document.querySelector() that selects the scrolling parent of CardList.\r\n * @returns Returns a grid of images of card in the set using filter options that are retrieved from redux store. Also displays \r\n * the number of cards owned by the user above each card image. \r\n */\r\nfunction CardList({ setId=null, scrollingParent=null, deckBuilder }) {\r\n    \r\n    // Get values from redux state\r\n    const { cardCollection } = useSelector(state => state.inventory);\r\n\r\n    const {\r\n        colors, searchTerm, searchType, showCards, cardCount, cmcs,\r\n        booster: boosterVal, set: reduxSets, cardTypes: reduxCardTypes, rarity: rarities,\r\n    } = useSelector(state => state.displayOptions);\r\n\r\n    const {\r\n        deckMap, sideboardMap, commander, companion, addBasics, deckType: reduxDeckType, addType,\r\n    } = useSelector(state => state.deckBuilder);\r\n\r\n    // Access redux dispatch\r\n    const dispatch = useDispatch();\r\n    \r\n    // Get the cards using the findCards Function\r\n    const cards = useMemo(() => {\r\n\r\n        // If all/none of the rarities selected, set rarityOption to undefined so findCards will not filter by rarity\r\n        let rarityOption = [];\r\n        for (const rarity in rarities) {\r\n\r\n            // Add rarity to rarityOption if it's selected\r\n            if (rarities[rarity]) {\r\n                rarityOption.push(rarity);\r\n            }\r\n        }\r\n\r\n        // Set rarityOption to undefined if all or none of the rarities are added to it\r\n        if (rarityOption.length < 1 || rarityOption.length > 3) {\r\n            rarityOption = undefined;\r\n        }\r\n        // Set booster to true, false, or undefined based on the value in redux\r\n        let booster;\r\n        switch (boosterVal) {\r\n            case \"In Boosters\":\r\n                booster = true;\r\n                break;\r\n            case \"Not In Boosters\":\r\n                booster = false;\r\n                break;\r\n            case \"All Cards\":\r\n                booster = undefined;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // Determine if set passed in as prop or received from redux\r\n        // Initialize set variable for use in searchOptions\r\n        let set;\r\n        // If a single SetId is provided --> use it\r\n        if (setId) {\r\n            set = setId;\r\n\r\n            // Otherwise get value(s) from redux \r\n        } else {\r\n\r\n            // If the redux value is empty, set = undefined so that findcards will disregard filtering by set\r\n            if (reduxSets.length === 0 ) {\r\n                set = undefined;\r\n\r\n            // If reduxSets has info, they need be altered so that set is an array of 3 letter set codes\r\n            } else {\r\n                set = [];\r\n                for ( const setObj of reduxSets) {\r\n                    set.push(setObj.val)\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Make cardTypes retrieved from redux into a usable form for findCards\r\n        // Currently is an array of objects --> Need just simple array\r\n\r\n        let cardTypes = undefined; // Initialize as undefined for case where reduxcardTypes is empty\r\n\r\n        if ( reduxCardTypes.length >= 1 ) {\r\n            cardTypes = []; // Change to empty array to add push method \r\n\r\n            for (const cardType of reduxCardTypes) {\r\n                // Only push the value property from reduxCardTypes into array\r\n                cardTypes.push(cardType.val);\r\n            }\r\n        }\r\n\r\n        // Make cmcs usuable for findCards\r\n        let selectedCMCs = undefined;\r\n        \r\n        if ( cmcs.length >= 1 ) {\r\n            selectedCMCs = [];\r\n            \r\n            for ( const cmc of cmcs) {\r\n                selectedCMCs.push(cmc.val);\r\n            }\r\n        }\r\n\r\n        // Set the decktype for searchOptions\r\n        let deckType = reduxDeckType;\r\n        // Ignore decktype when not in deckbuilder --> set to undefined\r\n        // Also if the redux value for deckType is limited or custom --> set to undefined because those modes have no specific legalities\r\n        if (!deckBuilder || reduxDeckType === 'limited' || reduxDeckType === 'custom') {\r\n            deckType = undefined;\r\n        }\r\n        \r\n        // Put all search options into a single object for findCards function\r\n        let searchOptions = {\r\n            set: set, color: colors, booster: booster, rarity: rarityOption, term: searchTerm,\r\n            advancedSearchType: searchType, cmcs: selectedCMCs, deckType: deckType, cardTypes: cardTypes\r\n        };\r\n\r\n        if (deckBuilder) {\r\n            \r\n            // If we are in the deckbuilder and are adding basic lands, we need different searchOptions\r\n            if (addBasics) {\r\n                searchOptions = { ...searchOptions, excludeBasicLands: false, cmcs: undefined, rarity: undefined, cardTypes: undefined}\r\n            }\r\n            // addType is used to show only commanders or companions. Not used when searching basic lands\r\n            else {\r\n                searchOptions.addType = addType;\r\n            }\r\n        }\r\n        \r\n        return findCards(searchOptions);\r\n        \r\n    }, [boosterVal, setId, reduxCardTypes, cmcs, reduxDeckType, deckBuilder, colors, searchTerm, searchType, rarities, reduxSets, addBasics, addType]);\r\n\r\n    // Track currently shown pictures\r\n    let currentPictures = [];\r\n\r\n    // Render cards based on how many the user owns using logic in 'showCards'\r\n    const renderCards = useMemo(() => {\r\n        let returnCards = [];\r\n        for (const card of cards) {\r\n\r\n            // Get number of card owned, if any\r\n            const numOwned = cardCollection[card.arenaId] ? cardCollection[card.arenaId] : 0;\r\n\r\n            // Initialize makeCard Boolean to false\r\n            let makeCard = false;\r\n\r\n            // Execute logic from showCards variable to determine whether card should be made\r\n            if (( showCards === 'Show All Cards' )                         ||\r\n                ( showCards === 'Own None' && numOwned === 0 )             ||\r\n                ( showCards === 'Own at Least One' && numOwned  >  0 )     ||\r\n                ( showCards === 'Missing at Least One' && numOwned  <  4 ) ||\r\n                ( showCards === 'Own Full Playset' && numOwned === 4))\r\n            {\r\n                makeCard = true;\r\n            }\r\n\r\n            // Don't make card if showCards logic says not to\r\n            if ( !makeCard ) {\r\n                continue;\r\n            }\r\n\r\n            // Track images to be displayed\r\n            currentPictures.push(card.imgs);\r\n\r\n            // Build card header\r\n            let cardHeader;\r\n\r\n            // Card Header for set view; number owned and buttons to change number owned\r\n            if (!deckBuilder) {\r\n                \r\n                cardHeader = (\r\n                    <ManualCollectionButtons card={card}>\r\n                        <div className=\"numOwned\" > {numOwned} / 4 </div>\r\n                    </ManualCollectionButtons>\r\n                );\r\n            }\r\n            \r\n            // In the deck builder, the card header indicates how many are owned as well as how many copies are in the deck\r\n            else {\r\n\r\n                // Circles are filled if owned and colored if added to deck\r\n                const circles = (() => {\r\n                    let temp = [];\r\n\r\n                    // Circles are declared left to right, but, if owned, filled right to left\r\n                    for (let i=0; i<4; i++) {\r\n\r\n                        // Initially assume circle is filled (owned copy of card)\r\n                        let circleClass = 'icon circle';\r\n\r\n                        // Check if circle should be an outline (not owned copy of card)\r\n                        if (i >= numOwned) {\r\n                            circleClass += ' outline';\r\n                        }\r\n\r\n                        // Get number of copies in deck and sideboard\r\n                        let copiesInDeck = 0;\r\n\r\n                        // Count the commander\r\n                        if (commander && commander.arenaId === card.arenaId) {\r\n                            copiesInDeck++;\r\n                        }\r\n\r\n                        if (companion && companion.arenaId === card.arenaId) {\r\n                            copiesInDeck++;\r\n                        }\r\n\r\n                        // Count the copies in the main deck\r\n                        if (deckMap[card.name] && deckMap[card.name][card.arenaId]) {\r\n                            copiesInDeck += deckMap[card.name][card.arenaId].copies;\r\n                        }\r\n                        // Count the copies in the sideboard\r\n                        if (sideboardMap[card.name] && sideboardMap[card.name][card.arenaId]) {\r\n                            copiesInDeck += sideboardMap[card.name][card.arenaId].copies;\r\n                        }\r\n\r\n                        // Color circles for number of cards in deck\r\n                        if (copiesInDeck && i < copiesInDeck) {\r\n                            circleClass += ' inDeck';\r\n                        }\r\n\r\n                        // Add circle to temp array\r\n                        temp.push(<i className={circleClass} key={`cir${i}_${card.arenaId}`}/>)\r\n                    }\r\n                    return temp;\r\n                })();\r\n\r\n\r\n                cardHeader = (\r\n                    <div className=\"content\">\r\n                        <div className=\"deckBuilder_circles\">\r\n                            {circles}\r\n                        </div>\r\n                    </div>\r\n                );\r\n            }\r\n\r\n            // Build card JSX\r\n            returnCards.push(\r\n                <CardListImage\r\n                    card={card} index={currentPictures.indexOf(card.imgs)} cardHeader={cardHeader} deckBuilder={deckBuilder}\r\n                    // Unique key for cards with undefined arenaIds\r\n                    key={card.arenaId ? card.arenaId : `${card.set}${card.collector_number}`}\r\n                />\r\n            );\r\n            \r\n        }\r\n        return returnCards;\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [cardCollection, cards, showCards, deckBuilder, deckMap, sideboardMap, commander, companion]);\r\n\r\n    // Track card images displayed, but only update redux state after JSX done rendering\r\n    useEffect( () => {\r\n        dispatch(updateImageList(currentPictures));\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [renderCards] );\r\n    \r\n    // Declare card dimensions for lazy loading\r\n    let width, height, gap, buffer, viewWidthFn;\r\n    if (deckBuilder) {\r\n        width = 160;\r\n        height = 257.5;\r\n        gap = 10;\r\n        buffer = 4;\r\n        viewWidthFn = viewWidth => viewWidth - 10;\r\n    } else {\r\n        width = 225;\r\n        height = 351.75;\r\n        gap = 20;\r\n        buffer = 3;\r\n        viewWidthFn = viewWidth => viewWidth - 17;\r\n    }\r\n\r\n    return (<>\r\n        {/* Counter for number of cards being displayed */}\r\n        {!deckBuilder ? <p id=\"displayingNumberCards\">\r\n            Displaying <span className=\"numCardsShown\">{cardCount}</span> card(s):\r\n        </p> : null}\r\n\r\n        {/* JSX for matching cards */}\r\n        <div className=\"cardList-cards\" >\r\n            <LazyLoad \r\n                childWidth={width} childHeight={height} gap={gap} buffer={buffer}\r\n                scrollingParent={scrollingParent} viewWidthFn={viewWidthFn}\r\n            >\r\n                {renderCards}\r\n            </LazyLoad>\r\n        </div>\r\n    </>);\r\n}\r\n\r\nexport default CardList;\r\n"],"sourceRoot":""}