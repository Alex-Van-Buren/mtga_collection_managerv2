{"version":3,"sources":["components/Templates/CustomDropdown.js","components/Templates/HoverPreview.js","components/Templates/MultiSelect.js","images/color_imgs/B.svg","images/color_imgs/R.svg","components/SetDetails/Reset.js","components/Templates/SearchBar.js","components/Templates/CustomCheckbox.js","images/color_imgs/W.svg","images/color_imgs/C.svg","images/color_imgs/M.svg","components/SetDetails/ColorCheckboxes.js","data/findCards.js","components/SetDetails/NumberOwnedDropdown.js","components/SetDetails/BoosterDropdown.js","components/SetDetails/CMCDropdowns.js","images/color_imgs/U.svg","images/color_imgs/G.svg","components/Templates/CustomButton.js","components/SetDetails/RarityButtons.js","components/SetDetails/CardTypeDropdown.js","components/All/CardListImage.js","hooks/useIsCardAddible.js","components/SetDetails/ManualCollectionButtons.js","components/Templates/LazyLoad.js","components/All/CardList.js"],"names":["CustomDropdown","items","labels","firstSelection","selectfn","undefined","ariaLabel","useState","open","setOpen","selected","setSelected","clickItem","item","useEffect","closeOnOutsideClick","document","body","addEventListener","removeEventListener","iconClass","itemsClass","selectedClass","toggleDropdown","event","stopPropagation","index","indexOf","className","tabIndex","onKeyDown","e","key","onClick","role","aria-expanded","aria-label","temp","i","label","push","length","dropdownItems","HoverPreview","children","imgs","height","width","delay","timerID","useRef","current","clearTimeout","locationRef","show","setShow","images","getBoundingClientRect","left","top","documentElement","clientHeight","clientWidth","x","y","getPosition","back","style","src","front","alt","onMouseOver","setTimer","onMouseOut","ref","onFocus","onBlur","onDragStart","createPortal","getElementById","setTimeout","MultiSelect","options","noneSelectedText","useValForSelected","initialSelected","selectedFn","topLabelContents","dropdownOptions","map","option","addOption","selectedOption","text","val","newState","addToSelected","filter","removeFromSelected","chevronClass","dropdownOptionsClass","Reset","value","action","resetDisplayOptions","SearchBar","advanced","term","setTerm","dispatch","useDispatch","initialSearchTerm","useSelector","state","displayOptions","searchTerm","initialSearchType","searchType","timeoutid","setSearchTerm","object","searchTypes","type","placeholder","autoComplete","aria-describedby","aria-controls","autoCapitalize","spellCheck","aria-haspopup","onChange","target","Object","keys","find","setSearchType","CustomCheckbox","labelText","checked","labelClass","inputClass","name","id","htmlFor","ColorCheckboxes","header","colorValues","colors","colorSVGs","W","U","B","R","G","C","M","colorLen","colorRefs","setColorRefs","Array","fill","_","createRef","renderColors","color","aria-checked","title","charAt","toUpperCase","slice","makeKeyboardClickable","onMouseLeave","blur","selectColor","filterSet","cardSet","set","isArray","includes","filterBasicLands","cardTypeLine","excludeBasicLands","filterColor","cardColor","searchColors","multi","white","blue","black","red","green","colorless","entries","symbol","filterRarity","cardRarity","rarity","filterBooster","cardBooster","booster","sortCards","cardList","sort","card1","card2","name1","name2","cmc","filterByTerm","card","advancedSearchType","match","printed_name","type_line","oracle_text","card_faces","face","checkText","filterCMC","cardCMC","selectedCMCs","selectedCMC","filterLegality","deckType","cardLegalities","filterCardTypes","cardTypes","keepCard","cardType","filterCompanions","keywords","filterCommanders","typeline","toLowerCase","findCards","searchOptions","searchCards","arenaCards","cmcs","addType","filterFunctions","color_identity","legalities","addCard","NumberOwnedDropdown","showCards","setShowCards","BoosterDropdown","selectBooster","CMCDropdowns","resetCount","selectCMCS","CustomButton","RarityButtons","rarities","renderRarityButtons","buttonClass","selectRarity","CardTypeDropdown","selectedCardTypes","types","selectCardTypes","CardListImage","cardImages","cardHeader","deckBuilder","flipRef","cardRef","isCardAddible","deckMap","sideboardMap","commander","companion","maxCopies","copiesInDeck","arenaId","copies","useIsCardAddible","imgSide","setImgSide","flipButton","onDragEnd","CardSide","addCardToDeck","addCardToSideboard","changeCommander","setAddType","changeCompanion","setDragCard","flip","animation","setCardModalContent","showCardModal","preventDefault","compose","draggable","ManualCollectionButtons","hovering","setHovering","onMouseEnter","removeCardFromCollection","addCardToCollection","LazyLoad","childHeight","childWidth","gap","buffer","scrollingParent","viewWidthFn","viewHeightFn","parent","window","viewHeight","innerHeight","viewWidth","innerWidth","element","querySelector","offsetHeight","offsetWidth","childrenPerRow","useMemo","Math","floor","numChildrenShown","setNumChildrenShown","ceil","throttleActive","onScrollY","scrollY","scrollTop","numChildrenWeNeedToShow","throttledOnScrollY","throttledFunction","CardList","setId","cardCollection","inventory","cardCount","boosterVal","reduxSets","reduxCardTypes","addBasics","reduxDeckType","cards","rarityOption","setObj","currentPictures","renderCards","returnCards","numOwned","makeCard","circles","circleClass","collector_number","updateImageList"],"mappings":"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","file":"static/js/0.13dc97d2.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\r\n\r\nimport '../../css/CustomDropdown.css';\r\n\r\n/**\r\n * Creates a dropdown menu where the selected item is displayed\r\n * @prop {Array} items An array of strings that are the different options that can be selected\r\n * @prop {Array} labels An array corresponding with items. items determines the value passed to the selectfn, while\r\n * labels determines what text is shown in the dropdown, if that label is defined. Only the specific labels that should\r\n * be overwritten need to be defined.\r\n * @example (with only one overwritten label): const labels = []; labels[4] = \"historic brawl\";\r\n * @prop {String} firstSelection The string of the default selection. Should be one of the strings in the items array.\r\n * @prop {Function} [selectfn=undefined] An additional callback function that uses the item selected as an argument.\r\n * @prop {String} [ariaLabel=undefined] An aria-label.\r\n * @returns Custom dropdown JSX.\r\n */\r\nfunction CustomDropdown({ items, labels=[], firstSelection, selectfn=undefined, ariaLabel=undefined }) {\r\n    const [open, setOpen] = useState(false);\r\n\r\n    // In some cases keeping track of selected might be redundant\r\n    const [selected, setSelected] = useState(firstSelection);\r\n    \r\n    // Close Dropdown on all clicks outside of dropdown\r\n    useEffect(() => {   \r\n        function closeOnOutsideClick() {\r\n            setOpen(false);\r\n        }\r\n        \r\n        document.body.addEventListener('click', closeOnOutsideClick);\r\n\r\n        return () => {\r\n            document.body.removeEventListener('click', closeOnOutsideClick);\r\n        }\r\n    }, []);\r\n\r\n    // Helper function for clicking an item in the dropdown\r\n    function clickItem(item) {\r\n\r\n        setSelected(item);\r\n        setOpen(false);\r\n\r\n        // Some Uses of dropdown may have additional things to do when selecting an option (like dispatch redux)\r\n        if (selectfn) {\r\n            selectfn(item);\r\n        }\r\n    }\r\n\r\n    // Map the Items\r\n    function dropdownItems() {\r\n        const temp = [];\r\n\r\n        for (let i=0; i<items.length; i++) {\r\n            const item = items[i];\r\n\r\n            // The displayed label may be different from the item\r\n            const label = labels[i] ? labels[i] : items[i];\r\n\r\n            temp.push(<div \r\n                className='dropdown-item' key={item} tabIndex='0' \r\n                onKeyDown={(e) => { if (e.key === 'Enter') clickItem(item) }} \r\n                onClick={() => clickItem(item)}\r\n                role='button' \r\n            >\r\n                {label}\r\n            </div>);\r\n        }\r\n\r\n        return temp;\r\n    }\r\n\r\n    // Closed dropdown classes\r\n    let iconClass = 'icon chevron down';\r\n    let itemsClass = 'dropdown-items dropdown-closed';\r\n    let selectedClass = 'dropdown-selected dropdown-closed'\r\n\r\n    // Change classes if dropdown is open\r\n    if (open) {\r\n        iconClass = 'icon chevron up';\r\n        itemsClass = 'dropdown-items';\r\n        selectedClass = 'dropdown-selected';\r\n    }\r\n\r\n    function toggleDropdown(event) {\r\n        event.stopPropagation();\r\n        setOpen(!open);\r\n    }\r\n\r\n    const index = items.indexOf(selected);\r\n\r\n    return (\r\n        <div className=\"dropdown\">\r\n            <div\r\n                className={selectedClass} tabIndex='0' \r\n                onKeyDown={(e) => { if (e.key === 'Enter') toggleDropdown(e) }} \r\n                onClick={(e) => toggleDropdown(e)}\r\n                role='button' aria-expanded={open} aria-label={ariaLabel}\r\n            >\r\n                {labels[index] ? labels[index] : items[index]} <span><i className={iconClass}/></span>\r\n\r\n            </div>\r\n            <div className={itemsClass}>{dropdownItems()}</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CustomDropdown;\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport { createPortal } from 'react-dom';\r\n\r\nimport '../../css/HoverPreview.css'\r\n\r\n/**\r\n * Wrap HoverPreview around JSX to create a hover preview. Returns the children wrapped in a div that's used\r\n * to determine the location of the JSX as well as add onClick, onMouseOver, and onMouseLeave events. Also creates\r\n * a portal to \"#hoverPreview\" to display the preview.\r\n * @prop {object} imgs An object of images to display. Requires imgs.front to contain an <img>, with imgs.back \r\n * to optionally display a second <img> tag next to it. Both images assumed to be same size.\r\n * @prop {number} [height=350] Optional height of image(s).\r\n * @prop {number} [width=247.07] Optional width of a SINGLE image. (Automatically doubled when imgs.back exists)\r\n * @prop {number} [delay=500] Optional parameter to set the delay time in ms.\r\n */\r\nexport default function HoverPreview({ children, imgs, height=350, width=247.07, delay=500 }) {\r\n\r\n    // Stores current timer when it exists\r\n    const timerID = useRef(null);\r\n    \r\n    // Cancel timers on unmount\r\n    useEffect(() => () => {\r\n        if (timerID.current) {\r\n            clearTimeout(timerID.current);\r\n        }\r\n    }, []);\r\n    \r\n    // Location of div wrapped around the children, used to determine hover preview location\r\n    const locationRef = useRef();\r\n\r\n    // Track whether to show this hover preview\r\n    const [show, setShow] = useState(false);\r\n\r\n    let images = null;\r\n    \r\n    // Add hover preview when locationRef is fully initialized\r\n    if (locationRef.current && imgs) {\r\n\r\n        // (x,y) coordinates of top, left corner\r\n        const { left, top } = locationRef.current.getBoundingClientRect();\r\n\r\n        // Will store the final (x,y) coordinates for the hover preview\r\n        const { x, y } = getPosition(height, imgs.back ? width*2 : width, left, top); // Double width if imgs.back\r\n        \r\n        images = (\r\n            <div className=\"hoverPreviewDiv\" style={{ left: x, top: y }}>\r\n                <img src={imgs.front} alt=\"hoverPreviewFrontImg\" className=\"hoverPreviewImg\" />\r\n                {imgs.back ? <img src={imgs.back}  alt=\"hoverPreviewBackImg\" className=\"hoverPreviewImg\" /> : null}\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    // Wrap children in a div to easily reference location\r\n    return (<>\r\n        <div\r\n            onMouseOver={setTimer} onMouseOut={onMouseOut} onClick={setTimer} ref={locationRef}\r\n            onFocus={setTimer} onBlur={onMouseOut} onDragStart={onMouseOut} \r\n            onKeyDown={(e) => {\r\n                if (e.key === \"Enter\") {\r\n                    setTimer();\r\n                }\r\n            }}\r\n        >\r\n            {children}\r\n        </div>\r\n        {show ? createPortal( images, document.getElementById(\"hoverPreview\") ) : null}\r\n    </>);\r\n\r\n    /**\r\n     * Cancels any active or pending hover preview when the mouse leaves this target.\r\n     */\r\n    function onMouseOut() {\r\n\r\n        // Clear the timer when the mouse leaves the target\r\n        clearTimeout(timerID.current);\r\n        timerID.current = null;\r\n\r\n        // Forcefully stop the hover preview on mouse leave\r\n        setShow(false);\r\n    }\r\n\r\n    /**\r\n     * Forcefully sets timer\r\n     */\r\n    function setTimer() {\r\n\r\n        // Clear any active timer\r\n        clearTimeout(timerID.current);\r\n\r\n        // Hide hover preview until timer is complete\r\n        setShow(false);\r\n\r\n        // Set a delay before showing the hover preview\r\n        timerID.current = setTimeout(() => {\r\n            \r\n            // Check if timer is still valid\r\n            if (timerID.current) {\r\n\r\n                // Clear timers\r\n                timerID.current = null;\r\n\r\n                // Show the hover preview once the coordinates are set\r\n                setShow(true);\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * Gets the x and y coordinates to place the preview at\r\n     */\r\n    function getPosition(height, width, left, top) {\r\n\r\n        // Get screen height and width\r\n        const { clientHeight, clientWidth } = document.documentElement;\r\n\r\n        // Default position at upper left corner of target\r\n        let x = left, y = top;\r\n\r\n        // Shift image left if off screen to the right\r\n        if (left + width > clientWidth) {\r\n            x = clientWidth - width - 1;\r\n        }\r\n\r\n        // Shift image up or down if off screen vertically\r\n        if (top < 0) {\r\n            y = 0;\r\n        } else if (top + height > clientHeight) {\r\n            y = clientHeight - height - 1;\r\n        }\r\n\r\n        // Set coordinates for the hover preview after ensuring the preview will be on-screen\r\n        return { x, y };\r\n    }\r\n}","import React, { useState, useEffect } from 'react';\r\n\r\nimport '../../css/MultiSelect.css';\r\n\r\n/**\r\n * A dropdown that allows for multiple selections\r\n * \r\n * @prop {Array} options An Array of the options that can be selected. Each option is an object that has text and val as keys\r\n * @prop {String} [noneSelectedText='Select...'] String to show when nothing is currently selected. Defaults to \"Select...\"\r\n * @prop {Boolean} [useValForSelected=false] A boolean that determines whether to use the val to represent the rendered button when that option selected. False by default\r\n * @prop {Array} [initialSelected=[]] Initially selected options. If using state management (eg redux), set this value to that state.\r\n * @prop {Function} [selectedFn=undefined] A function to run when the selected options change.\r\n * @returns JSX for multiselectable dropdown\r\n */\r\nfunction MultiSelect({ options, noneSelectedText = 'Select...', useValForSelected = false, initialSelected = [], selectedFn = undefined }) {\r\n\r\n    // Close Dropdown on all clicks outside of dropdown\r\n    useEffect(() => {\r\n        function closeOnOutsideClick() {\r\n            setOpen(false);\r\n        }\r\n\r\n        document.body.addEventListener('click', closeOnOutsideClick);\r\n\r\n        return () => {\r\n            document.body.removeEventListener('click', closeOnOutsideClick);\r\n        }\r\n    }, []);\r\n\r\n    const [open, setOpen] = useState(false);\r\n    const [selected, setSelected] = useState(initialSelected);\r\n\r\n    // Helper function to add an option to selected if is not there already\r\n    function addToSelected(option) {\r\n        // initialize add to selected to be true\r\n        let addOption = true;\r\n\r\n        // Check each option currently selected and see if the option to be added is already selected\r\n        for (const selectedOption of selected) {\r\n            if (selectedOption.text === option.text && selectedOption.val === option.val) {\r\n                addOption = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If the option passed and wasn't already selected --> Add it \r\n        if (addOption) {\r\n            const newState = [...selected, option];\r\n\r\n            // Update local state and use extra function if provided\r\n            setSelected(newState);\r\n            if (selectedFn) {\r\n                selectedFn(newState);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Map all of the options with add function\r\n    const dropdownOptions = options.map((option) => {\r\n        return (\r\n            <div className=\"multi-option\"\r\n                onClick={(e) => { e.stopPropagation(); addToSelected(option) }}\r\n                key={option.val}\r\n            >\r\n                {option.text}\r\n            </div>\r\n        );\r\n    });\r\n\r\n    // Helper function to remove an option from selected\r\n    function removeFromSelected(event, option) {\r\n        event.stopPropagation();\r\n        const newState = selected.filter(current => current !== option);\r\n\r\n        // Update local state and use extra function if provided\r\n        setSelected(newState);\r\n        if (selectedFn) {\r\n            selectedFn(newState);\r\n        }\r\n    }\r\n\r\n    // Initialize top-level multiselect contents\r\n    let topLabelContents;\r\n\r\n    // If nothing is selected, render \"Select...\" or provided text\r\n    if (selected.length === 0) {\r\n        topLabelContents = noneSelectedText;\r\n    }\r\n\r\n    // Else map all selected options and render them\r\n    else {\r\n        topLabelContents = selected.map((option) => {\r\n            return (\r\n                <button key={option.val} onClick={(e) => removeFromSelected(e, option)}>\r\n                    {useValForSelected ? option.val : option.text}\r\n                    <i className=\"delete icon\"></i>\r\n                </button>\r\n            );\r\n        });\r\n    }\r\n\r\n    // Class definitions that change if dropdown is open\r\n    let chevronClass = \"icon chevron down\";\r\n    let dropdownOptionsClass = \"options\";\r\n    let selectedClass = \"selected\";\r\n\r\n    if (open) {\r\n        chevronClass = \"icon chevron up\";\r\n        dropdownOptionsClass = \"options active\";\r\n        selectedClass = \"selected active\";\r\n    }\r\n\r\n    return (\r\n        <div className=\"multi-dropdown\">\r\n            <div className={selectedClass} onClick={(e) => { e.stopPropagation(); setOpen(!open) }}>\r\n                {topLabelContents}\r\n                <i className={chevronClass}></i>\r\n            </div>\r\n            <div className={dropdownOptionsClass}>\r\n                {dropdownOptions}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default MultiSelect;\r\n","export default __webpack_public_path__ + \"static/media/B.7f78a23f.svg\";","export default __webpack_public_path__ + \"static/media/R.b8e69eab.svg\";","import React from 'react';\r\n\r\nimport Custombutton from '../Templates/CustomButton';\r\nimport { resetDisplayOptions } from '../../actions';\r\nimport '../../css/Reset.css';\r\n\r\nfunction Reset() {\r\n    const resetBtnClass = 'ui button positive reset-button';\r\n    return(\r\n        <Custombutton value=\"Reset\" action={resetDisplayOptions} className={resetBtnClass} />\r\n    )\r\n}\r\n\r\nexport default Reset;","import React, { useState, useEffect } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport { setSearchTerm, setSearchType } from '../../actions';\r\nimport CustomDropdown from './CustomDropdown';\r\nimport '../../css/SearchBar.css';\r\n\r\n/**\r\n * Updates redux state with searchTerm from search bar input\r\n * @returns Search bar JSX\r\n */\r\nfunction SearchBar({advanced=true}) {\r\n    \r\n    // Track current search term for controlled input\r\n    const [term, setTerm] = useState(\"\");\r\n\r\n    // Get access to dispatch\r\n    const dispatch = useDispatch();\r\n\r\n    // Get initial search term from redux\r\n    const initialSearchTerm = useSelector(state => state.displayOptions.searchTerm);\r\n    const initialSearchType = useSelector(state => state.displayOptions.searchType);\r\n\r\n    // Update initial Search Term and Type on first load\r\n    useEffect(() => {\r\n        setTerm(initialSearchTerm);\r\n    }, [initialSearchTerm]);\r\n\r\n    // Track change in search bar (debounced)\r\n    useEffect(() => {\r\n\r\n        // Wait for user to stop typing\r\n        const timeoutid = setTimeout( () => {\r\n            dispatch(setSearchTerm(term));\r\n        }, 500);\r\n\r\n        // Cleanup function to stop search\r\n        return () => clearTimeout(timeoutid);\r\n    }, [term, dispatch]);\r\n\r\n    // Search types object: keys are strings to be displayed to user, values are redux values to be used in findCards search\r\n    const searchTypes = {\"All Text\": null, \"Name\": \"name\", \"Type Line\": \"type_line\", \"Card Text\": 'oracle_text'};\r\n    \r\n    // Function that is put into dropdown to select a search term and update redux\r\n    function searchTypeSelect(item) {\r\n        dispatch(setSearchType(searchTypes[item]));\r\n    }\r\n    \r\n    // Function that returns the key that the corresponding value is attributed to\r\n    function getKeyByValue(object, val) {\r\n        return Object.keys(object).find(key => object[key] === val);\r\n    }\r\n\r\n    return (\r\n        <div className=\"search\">\r\n            <input\r\n                // Data\r\n                type=\"search\" placeholder=\"Search Card Text:\" className=\"searchBar\"\r\n\r\n                // Accessibility\r\n                autoComplete=\"off\" aria-describedby=\"searchKeyboardControls\" aria-label=\"Search Card Text\"\r\n                aria-controls=\"results\" autoCapitalize=\"none\" spellCheck=\"false\" aria-haspopup=\"false\"\r\n                \r\n                // Controlled input\r\n                value={term} onChange={ (e) => setTerm(e.target.value) }\r\n            />\r\n            <button className={advanced ? \"clearSearchBar\" : \"clearSearchBarSimple\"} onClick={() => setTerm(\"\")}><i className=\"close icon\"/></button>\r\n            \r\n            { // Determine whether to show advanced search\r\n                advanced ? \r\n                <CustomDropdown \r\n                    items={Object.keys(searchTypes)} key={`SearchType ${initialSearchType}`} ariaLabel=\"Select Search Type\"\r\n                    firstSelection={getKeyByValue(searchTypes, initialSearchType)} \r\n                    selectfn={searchTypeSelect}\r\n                /> : null\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SearchBar;","import React from 'react';\r\n\r\n/**\r\n * A custom checkbox\r\n * @param {string} props.text Text for the checkbox\r\n * @param {boolean} props.checked True/false the checkbox is checked\r\n * @param {function} props.onChange Function to execute on checkbox change\r\n * @param {string} props.labelClass Class name(s) for the label\r\n * @param {string} props.inputClass Class name(s) for the input\r\n * @returns Checkbox JSX\r\n */\r\nexport default function CustomCheckbox({ text, labelText=text, checked, onChange, labelClass, inputClass }) {\r\n\r\n    return (\r\n        <>\r\n            {/* Checkbox input */}\r\n            <input type=\"checkbox\" name={text} id={text} checked={checked} onChange={onChange} className={inputClass}/>\r\n            \r\n            {/* Checkbox Label */}\r\n            <label htmlFor={text} className={labelClass}>{labelText}</label>\r\n        </>\r\n    );\r\n}","export default __webpack_public_path__ + \"static/media/W.99c7fe1b.svg\";","export default __webpack_public_path__ + \"static/media/C.4af949b5.svg\";","export default __webpack_public_path__ + \"static/media/M.fb91d492.svg\";","import React, { createRef, useEffect, useState } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport { selectColor } from '../../actions';\r\nimport CustomCheckbox from '../Templates/CustomCheckbox';\r\nimport makeKeyboardClickable from '../../hooks/makeKeyboardClickable';\r\nimport '../../css/ColorCheckboxes.css';\r\n\r\n// Import SVG images\r\nimport W from '../../images/color_imgs/W.svg';\r\nimport U from '../../images/color_imgs/U.svg';\r\nimport B from '../../images/color_imgs/B.svg';\r\nimport R from '../../images/color_imgs/R.svg';\r\nimport G from '../../images/color_imgs/G.svg';\r\nimport C from '../../images/color_imgs/C.svg';\r\nimport M from '../../images/color_imgs/M.svg';\r\n\r\nexport default function ColorCheckboxes({ header }) {\r\n\r\n    // Access the redux dispatcher\r\n    const dispatch = useDispatch();\r\n\r\n    // Get currently selected colors from redux state\r\n    const colorValues = useSelector( state => state.displayOptions.colors );\r\n\r\n    // List card colors and the tags needed for their icons\r\n    const colors = ['white', 'blue', 'black', 'red', 'green', 'colorless', 'multi'];\r\n    const colorSVGs = [ W, U, B, R, G, C, M ];\r\n    \r\n    /* REALLY CONVOLUTED WAY TO MAKE ELEMENTS FROM MAP KEYBOARD ACCESSIBLE */\r\n        // Need to keep track of length of colors array, because references depend on it\r\n        const colorLen = colors.length;\r\n        // Use state to rerender component upon change\r\n        const [colorRefs, setColorRefs] = useState([]);\r\n        useEffect(() => {\r\n            // Set state to keep track of refs to each color checkbox\r\n            setColorRefs(colorRefs => (\r\n                // Fill colorRefs array - keeping current ref if it exists, otherwise make a new one\r\n                Array(colorLen).fill().map((_, i) => colorRefs[i] || createRef())\r\n            ));\r\n        }, [colorLen]);\r\n    /* End convoluted keyboard accessibility stuff */\r\n\r\n    // Create color checkboxes for each\r\n    const renderColors = colors.map( (color, i) => {\r\n\r\n        const iconClass = colorValues[color] ? \"big colorIcon\" : \"colorIcon\";\r\n\r\n        return (\r\n            <div className=\"colorCheckbox\" key={color}>\r\n                <CustomCheckbox\r\n                    // Data\r\n                    text={color} key={color} checked={colorValues[color]}\r\n    \r\n                    // Icon\r\n                    labelText={ <img\r\n                        className={iconClass} src={colorSVGs[i]} alt=\"icon\"\r\n\r\n                        // Keyboard accessibility\r\n                        aria-controls={color} role=\"checkbox\" aria-checked={colorValues[color]} tabIndex=\"0\"\r\n                        aria-label={color} ref={ colorRefs[i] } title={color.charAt(0).toUpperCase() + color.slice(1)}\r\n                        onKeyDown={ (e) => makeKeyboardClickable(e, colorRefs[i])}\r\n\r\n                        // Blur when hover ends and blur when deselected\r\n                        onMouseLeave={ () => colorRefs[i].current.blur() }\r\n                        onClick={ () => colorRefs[i].current.blur() }\r\n                    /> }\r\n    \r\n                    // Classes\r\n                    labelClass=\"colorBoxInputLabel\" inputClass=\"colorBoxInput\"\r\n    \r\n                    // Dispatch redux action\r\n                    onChange={(e) => dispatch( selectColor(e.target.name, e.target.checked) )}\r\n                />\r\n            </div>\r\n        );\r\n    });\r\n\r\n    return (\r\n        \r\n        // Checkboxes for color: White, Blue, Black, Red, Green, All Multicolored, Colorless\r\n        <div className=\"colorBox\">\r\n            <label htmlFor=\"color\" className=\"colorBoxLabel\">{ header }</label>\r\n            <div className=\"colorList\">\r\n                {renderColors}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n","import arenaCards from \"./arenaCards\";\r\n\r\n//  const allArenaCards = require('./arenaCards20210719155815.json')\r\n/**\r\n * \r\n * @param {*} searchOptions Object of options to filter the cards on Arena. Define as an object eg{set:'setId', name:'cardName', color: ['W', 'G'] \r\n * (color also accepts 'colorless' or 'multi'), rarity: ['rarity1','rarity2'], booster: boolean}\r\n * @param {*} returnOptions An Array of addtional properties to retrieve eg ['image_uris', 'set', 'cmc', etc]\r\n * @param {} searchCards Optional. A List of card objects to search. Defaults to all cards on arena.\r\n * @param {boolean} sort Optional. Boolean to sort the found cards. Defaults to true.\r\n * @returns An array of the cards found\r\n */\r\nfunction findCards(searchOptions, searchCards=arenaCards, sort=true) {\r\n\r\n    // Destructure search options\r\n    const { set, color, rarity, booster, term, advancedSearchType=null, excludeBasicLands=true, cmcs, deckType, cardTypes, addType } = searchOptions;\r\n\r\n    /**\r\n     * An array of ananymous functions to be called on each card\r\n     * - Each function must take ONLY the card as a parameter.\r\n     * @param {Object} card The card to be tested.\r\n     */\r\n    const filterFunctions = [];\r\n\r\n/* DETERMINE WHICH FUNCTIONS NEED TO BE CALLED ON EACH CARD */\r\n\r\n    // Only show Companions if requested\r\n    if (addType === \"companion\") {\r\n        filterFunctions.push( (card) => filterCompanions(card.keywords));\r\n    }\r\n\r\n    // Only show Commanders if requested\r\n    if (addType === \"commander\") {\r\n        filterFunctions.push( (card) => filterCommanders(card.type_line));\r\n    }\r\n\r\n    // Filter by set if needed\r\n    if (set) {\r\n        filterFunctions.push( (card) => filterSet(card.set, set) );\r\n    }\r\n\r\n    // Filter by name if needed\r\n    if (term) {\r\n        filterFunctions.push( (card) => filterByTerm(card, term, advancedSearchType) );\r\n    }\r\n\r\n    // Filter by color if needed\r\n    if (color) {\r\n\r\n        // If all colors are false, don't filter by color\r\n        if (!(color.white || color.blue || color.black || color.red || color.green || color.colorless || color.multi)) {\r\n            // Don't add function\r\n\r\n        }\r\n        // If multi AND colorless are selected, 0 cards returned from findCards function\r\n        else if ( color.multi && color.colorless ) {\r\n            \r\n            // Exit filterFunction definition and return empty array\r\n            return [];\r\n\r\n        } else {\r\n            filterFunctions.push( (card) => filterColor(card.color_identity, color) );\r\n        }\r\n    }\r\n\r\n    // Filter by rarity if needed\r\n    if (rarity) {\r\n        filterFunctions.push( (card) => filterRarity(card.rarity, rarity) );\r\n    }\r\n\r\n    // Filter Out Basic Lands OR only show basic lands\r\n    filterFunctions.push( (card) => filterBasicLands(card.type_line, excludeBasicLands) );\r\n\r\n    // Filter booster if needed\r\n    if (booster !== undefined) {\r\n        filterFunctions.push( (card) => filterBooster(card.booster, booster) );\r\n    }\r\n\r\n    // Filter cmc if needed\r\n    if (cmcs) {      \r\n        filterFunctions.push( (card) => filterCMC(card.cmc, cmcs) );\r\n    }\r\n\r\n    // Filter Card legality if needed\r\n    if ( deckType ) {\r\n        filterFunctions.push( (card) => filterLegality( deckType, card.legalities));\r\n    }\r\n\r\n    // Filter Card Types if needed\r\n    if ( cardTypes ) {\r\n        filterFunctions.push( (card) => filterCardTypes(card.type_line, cardTypes));\r\n    }\r\n\r\n/* Call each chosen filter function on each card */\r\n\r\n    // Card list will hold chosen cards\r\n    let cardList = [];\r\n\r\n    for (const card of searchCards) { // Loop over cards\r\n        let addCard = true;\r\n\r\n        for (let i=0; i<filterFunctions.length; i++) { // Loop over filter functions\r\n\r\n            // Call filter function on card and stop calling filter functions if one returns false\r\n            if (!filterFunctions[i](card)) {\r\n                addCard = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Decide whether to add card to card list\r\n        if (addCard) {\r\n\r\n            // Push card with desired properties to card list\r\n            cardList.push(card);\r\n        }\r\n    }\r\n\r\n    // Sort the cards \r\n    if (sort) {\r\n        sortCards(cardList);\r\n    }\r\n\r\n    return cardList;\r\n}\r\n\r\n/**\r\n * Filter cards not in specified set.\r\n * @param {String} cardSet Set code of the card\r\n * @param {any} set Either a string that is the desired Set or an array of the desired 3 letter set codes\r\n * @returns True if cardSet and set match or if cardSet is included in array, false otherwise.\r\n */\r\n function filterSet(cardSet, set) {\r\n\r\n    // Filter cards not in the set\r\n    if (set === cardSet || ( Array.isArray(set) && set.includes(cardSet) )) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * We either wnat to filter out basic lands from our search or only show basic lands\r\n * Filters out Basic Lands if excludeBasicLands is true.\r\n * If excludeBasicLands is false. Will filter out anything that is NOT a basic land.\r\n * @param {String} cardTypeLine The type line of the card to check\r\n * @param {boolean} excludeBasicLands True to filter out basic lands, false to filter out cards that are NOT basic lands\r\n * @returns Returns true if the card should be included in findCards array, false if it shouldn't\r\n */\r\nfunction filterBasicLands(cardTypeLine, excludeBasicLands) {\r\n\r\n    if ( excludeBasicLands ) {\r\n        // Skip basic lands\r\n        if ( cardTypeLine.includes('Basic') && cardTypeLine.includes('Land') ){\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    // excludeBasicLands === false\r\n    // The same code as above but the return boolean is flipped\r\n    if ( cardTypeLine.includes('Basic') && cardTypeLine.includes('Land') ){\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\n/**\r\n * Filter by Color helper function\r\n * @param {Array} cardColor Array of strings containing the color identities of the card to be checked.\r\n * @param {Object} searchColors Object containing the boolean values for the desired colors.\r\n * @returns True if the card colors match the search colors (logic is more complex for multi and colorless).\r\n * Returns false if the card colors don't match.\r\n */\r\nfunction filterColor(cardColor, searchColors) {\r\n        \r\n    // Multi false logic\r\n    if ( !searchColors.multi ) {\r\n\r\n        // If the card contains any of the WUBRG colors that are being searched for\r\n        if ((searchColors.white && cardColor.includes('W')) ||\r\n            (searchColors.blue  && cardColor.includes('U')) ||\r\n            (searchColors.black && cardColor.includes('B')) ||\r\n            (searchColors.red   && cardColor.includes('R')) ||\r\n            (searchColors.green && cardColor.includes('G')))\r\n        {\r\n            // Card matches a color\r\n            return true;\r\n        }\r\n\r\n        // Check if colorless is true and the card is colorless\r\n        if ( searchColors.colorless && (cardColor.length === 0) ) {\r\n\r\n            // Card matches colorless\r\n            return true;\r\n        }\r\n\r\n        // No multi-color match found\r\n        return false;\r\n    }\r\n\r\n    // Multi true\r\n    else {\r\n\r\n        // Check if card has more than one color in color identity\r\n        if ( cardColor.length < 2 ) {\r\n\r\n            // Card isn't multi-color\r\n            return false;\r\n        }\r\n        \r\n        // Check if multi is the only color option that is true\r\n        if ( searchColors.multi && \r\n             !( searchColors.white || searchColors.blue  || searchColors.black || \r\n                searchColors.red   || searchColors.green || searchColors.colorless )\r\n           )\r\n        {\r\n            // Card is multi-color\r\n            return true;\r\n        }\r\n\r\n        // Card must include ALL required colors but may include addtional colors\r\n        const colors = { 'white' : 'W', 'blue'  : 'U', 'black' : 'B', 'red'   : 'R', 'green' : 'G' };\r\n        \r\n        for (const [name, symbol] of Object.entries(colors)) {\r\n            \r\n            // Make sure card has all required colors\r\n            if ( searchColors[name] && !cardColor.includes(symbol) ) {\r\n\r\n                // Card doesn't include a required color\r\n                return false;\r\n            } \r\n        }\r\n        // Card includes all required colors\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Check if the card's rarity is in the rarity array\r\n * @param {String} cardRarity The rarity of the card to be checked.\r\n * @param {Array} rarity The array of desired rarities.\r\n * @returns True when the card's rarity is in the rarities array.\r\n */\r\nfunction filterRarity(cardRarity, rarity) {\r\n\r\n    // Check if the rarity array contains the rarity of the card\r\n    if (rarity.includes(cardRarity)) {\r\n        return true;\r\n    }\r\n    return false;\r\n        \r\n}\r\n\r\n/**\r\n * Checks if the card's booster value and the desired booster value match\r\n * @param {boolean} cardBooster The card's booster value\r\n * @param {boolean} booster The desired booster value.\r\n * @returns True if the desired value for booster and the card's booster value match.\r\n */\r\nfunction filterBooster(cardBooster, booster) {\r\n\r\n    if (cardBooster === booster) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Sorts a list of MTG Arena cards \r\n * @param {Array} cardList The array containing the cards to be sorted.\r\n * @returns An array of cards sorted by converted mana cost, then alphabetically within each cmc group.\r\n */\r\nfunction sortCards(cardList) {\r\n\r\n    // First sorts alphabetically\r\n    cardList.sort( (card1, card2) => {\r\n        const name1 = card1.name.toUpperCase(); // ignore upper and lowercase\r\n        const name2 = card2.name.toUpperCase();\r\n\r\n        if (name1 < name2)\r\n            return -1\r\n        if (name1 > name2)\r\n            return 1\r\n        // Names are equal\r\n        return 0\r\n    });\r\n\r\n    // Then by cmc\r\n    cardList.sort( (card1, card2) => {\r\n        return card1.cmc - card2.cmc\r\n    })\r\n}\r\n\r\n/**\r\n * Searches card for specified search term (includes partial matches).\r\n * - If advancedSearchType is specified, an advanced search is performed.\r\n * - An advanced search searches only the card section specified by the string in advancedSearchType.\r\n * @param {Object} card Card object to search. Only uses name, type_line, oracle_text, and card_faces properties.\r\n * @param {string} term The search term to match.\r\n * @param {string} advancedSearchType Regular search if unspecified. If specified, creates an advanced search.\r\n * \"name\", \"type_line\", and \"oracle_text\" are the allowed advanced search types, indicating the specific card section to search.\r\n * @returns True if the card contains the search term, false otherwise. (Or matches advanced search options if specified)\r\n */\r\n function filterByTerm(card, term, advancedSearchType=null) {\r\n\r\n    // Normal search\r\n    if (!advancedSearchType) {\r\n\r\n        if (\r\n            // Check name\r\n            match(card.name) ||\r\n    \r\n            // Check type line\r\n            match(card.type_line) ||\r\n        \r\n            // Check oracle text if it exists\r\n            ( card.oracle_text && match(card.oracle_text) ) ||\r\n\r\n            // Check printed_name if it exists\r\n            ( card.printed_name && match(card.printed_name) )\r\n        ) {\r\n            return true;\r\n        }\r\n    \r\n        // Need to check card faces in order to find some cards\r\n        if (card.card_faces) {\r\n    \r\n            // Check for oracle_text match on either face\r\n            for (const face of card.card_faces) {\r\n    \r\n                if ( face.oracle_text && match(face.oracle_text) ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Advanced search\r\n    else {\r\n        switch (advancedSearchType) {\r\n\r\n            case \"name\":\r\n                // Check name only\r\n                if ( match(card.name) || (card.printed_name && match(card.printed_name))) {\r\n                    return true;\r\n                }\r\n                return false;\r\n\r\n            case \"type_line\":\r\n                // Check type line only\r\n                if ( match(card.type_line) ) {\r\n                    return true;\r\n                }\r\n                return false;\r\n\r\n            case \"oracle_text\": {\r\n                // Check oracle text\r\n                if (card.oracle_text && match(card.oracle_text)) {\r\n                    return true;\r\n                }\r\n\r\n                // Need to check card faces in order to find some cards\r\n                if (card.card_faces) {\r\n            \r\n                    // Check for oracle_text match on either face\r\n                    for (const face of card.card_faces) {\r\n            \r\n                        if ( face.oracle_text && match(face.oracle_text) ) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    // False if no match found above\r\n    return false;\r\n\r\n    // Helper function to make comparing the search term less verbose. Compares input to search term\r\n    function match(checkText) {\r\n        return checkText.toUpperCase().includes(term.toUpperCase());\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if a card should be kept in the finalCards array based on the cmc of the card and selected CMCs\r\n * @param {Number} cardCMC The converted mana cost of card\r\n * @param {*} selectedCMCs Array of values of cmcs to be accepted. \r\n * @returns Returns true if the card should be kept. False if not\r\n */\r\nfunction filterCMC(cardCMC, selectedCMCs) {\r\n\r\n    for (const selectedCMC of selectedCMCs) {\r\n        // Check if the value is '8+'\r\n        if ( selectedCMC === '8+' ) {\r\n            if ( cardCMC >= 8 ) {\r\n                return true;\r\n            }\r\n\r\n        } else {\r\n            if (selectedCMC === cardCMC){\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if a card is legal in the format given\r\n * @param {string} deckType The desired decktype format to check.\r\n * @param {object} cardLegalities The legalities object of the card to check\r\n * @returns {boolean} Returns true if the card should be kept. False if not\r\n */\r\nfunction filterLegality(deckType, cardLegalities) {\r\n    // Check the card legality of the given decktype\r\n    if ( cardLegalities[deckType] === 'legal'){\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if the card is a wanted type. \r\n * @param {string} cardTypeLine The type_line of the individual card to be checked.\r\n * @param {*} cardTypes Array of card types to keep\r\n * @returns Returns true if the card should be kept. False if not\r\n */\r\nfunction filterCardTypes(cardTypeLine, cardTypes) {\r\n    let keepCard = false // Initialize return boolean to false;\r\n\r\n    for (const cardType of cardTypes) {\r\n        if ( cardTypeLine.includes(cardType)) {\r\n            keepCard = true;\r\n            break;\r\n        }\r\n    }\r\n    return keepCard\r\n}\r\n\r\n/**\r\n * Determines whether this card is a companion.\r\n * @param {array} keywords The key words for the card. Will contain \"Companion\" if this card is a companion.\r\n * @returns True if the card is a Companion.\r\n */\r\nfunction filterCompanions(keywords) {\r\n    if (keywords.includes(\"Companion\")) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines whether this card is a commander.\r\n * @param {string} typeline The type line for the card. Will contain \"Legendary\" + (\"Creature\" OR \"Planeswalker\") if valid.\r\n * @returns True if the card is a Commander.\r\n */\r\nfunction filterCommanders(typeline) {\r\n    typeline = typeline.toLowerCase();\r\n    if (typeline.includes(\"legendary\") && ( typeline.includes(\"creature\") || typeline.includes(\"planeswalker\") )) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport default findCards;\r\n","import React from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport CustomDropdown from '../Templates/CustomDropdown';\r\nimport { setShowCards } from '../../actions';\r\nimport '../../css/NumberOwnedDropdown.css';\r\n\r\nfunction NumberOwnedDropdown({ header }) {\r\n    const dispatch = useDispatch();\r\n\r\n    // Need to check redux for first Selection in cases where something else changes the state of the dropdown (eg reset button)\r\n    const firstSelection = useSelector(state => state.displayOptions.showCards);\r\n\r\n    const items = ['Own None', 'Own at Least One', 'Missing at Least One', 'Own Full Playset', 'Show All Cards'];\r\n\r\n    function selectfnNumberOwned(item) {\r\n        dispatch(setShowCards(item))\r\n    }\r\n\r\n    return (\r\n        <div className=\"numberOwnedDropdown\">\r\n            <label>{ header }</label>\r\n            <CustomDropdown \r\n                ariaLabel=\"Filter by Number Owned\" items={items} key={firstSelection} \r\n                firstSelection={firstSelection} selectfn={selectfnNumberOwned} \r\n            />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default NumberOwnedDropdown;","import React from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport CustomDropdown from '../Templates/CustomDropdown';\r\nimport { selectBooster }  from '../../actions/index';\r\nimport '../../css/BoosterDropdown.css';\r\n\r\nfunction BoosterDropdown({ header }) {\r\n\r\n    const dispatch = useDispatch();\r\n    const firstSelection = useSelector(state => state.displayOptions.booster);\r\n\r\n    return (\r\n        <div className=\"boosterDropdown\">\r\n            <label>{ header }</label>\r\n            <CustomDropdown \r\n                ariaLabel=\"Filter Cards by Booster Pack Availability\"\r\n                items={['Show All Cards', 'In Boosters', 'Not In Boosters']}\r\n                key={firstSelection} \r\n                firstSelection={firstSelection}\r\n                selectfn={(item) => dispatch(selectBooster(item))}\r\n            />\r\n        </div>        \r\n    )\r\n}\r\n\r\nexport default BoosterDropdown;\r\n","import React from 'react';\r\nimport { useDispatch, useSelector} from 'react-redux';\r\n\r\nimport MultiSelect from '../Templates/MultiSelect';\r\nimport { selectCMCS } from '../../actions';\r\nimport '../../css/CMCDropdowns.css';\r\n\r\nfunction CMCDropdowns({ header }) {\r\n\r\n    const dispatch = useDispatch();\r\n\r\n    // Get the current selections from redux\r\n    const cmcs = useSelector( state => state.displayOptions.cmcs);\r\n    const key = useSelector(state => state.displayOptions.resetCount);\r\n\r\n    const items = [0,1,2,3,4,5,6,7,'8+'];\r\n    const options = [];\r\n    for (const item of items) {\r\n        options.push({text: item, val: item});\r\n    } \r\n    return (\r\n        <div className=\"CMCDropdowns\">\r\n            <label>{header}</label> \r\n            <div className=\"CMCDropdowns-container\">\r\n                <div className=\"pickCMC\">\r\n                    <MultiSelect \r\n                        options={options} initialSelected={cmcs} \r\n                        selectedFn={(selected) => dispatch(selectCMCS(selected))}\r\n                        key={key} noneSelectedText='All'\r\n                    />\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CMCDropdowns;","export default __webpack_public_path__ + \"static/media/U.8fcc549b.svg\";","export default __webpack_public_path__ + \"static/media/G.1e9be629.svg\";","import React, { useRef } from 'react';\r\nimport { useDispatch } from 'react-redux';\r\n\r\n/**\r\n * A custom React-Redux button.\r\n * @param {function} action The raw action to dispatch.\r\n * @param {any} value The value to be dispatched.\r\n * @param {string} className Class name(s) to be applied to the button. Equal to \"\" if not specified.\r\n * @param {string} text The button text. Equal to value if not specified.\r\n * @returns Button JSX\r\n */\r\nexport default function CustomButton({ action, value, className=\"\", text=value }) {\r\n\r\n    // Access redux reducer\r\n    const dispatch = useDispatch();\r\n\r\n    // Add a ref to blur button\r\n    const ref = useRef();\r\n\r\n    return (\r\n        <button \r\n            className={className}\r\n            ref={ref}\r\n            onClick={ () => {\r\n\r\n                // Dispatch the action\r\n                dispatch(action(value));\r\n\r\n                // Deselect the button\r\n                ref.current.blur();\r\n            } }\r\n        >\r\n            {text}\r\n        </button>\r\n    );\r\n}","import React from 'react';\r\nimport { useSelector } from 'react-redux';\r\n\r\nimport { selectRarity } from '../../actions';\r\nimport CustomButton from '../Templates/CustomButton';\r\nimport '../../css/RarityButtons.css';\r\n\r\n/**\r\n * The rarity buttons selecter for card filtering. \r\n * @param {String} props.header The string for the label of the Rarity buttons\r\n * @returns JSX for rarity buttons\r\n */\r\nfunction RarityButtons({header}) {\r\n    const rarities  = useSelector(state => state.displayOptions.rarity);\r\n    \r\n    // Create array of rarity buttons\r\n    const renderRarityButtons = [];\r\n\r\n    // Loop through each rarity and check whether it's currently selected\r\n    for (const rarity in rarities) {\r\n        let buttonClass = `ui button primary rarityButton ${rarity}`;\r\n\r\n        // If the rarity isn't currently selected, add \"basic\" to its class\r\n        if ( !rarities[rarity] )\r\n            buttonClass += ' basic';\r\n        \r\n        // Then push that rarity button to the array\r\n        renderRarityButtons.push(<CustomButton action={selectRarity} className={buttonClass} value={rarity} key={rarity} />);\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            {/* Buttons that select rarity: Mythic, Rare, Uncommon, Common */}\r\n            <label className=\"rarityLabel\">{header}</label>\r\n            <div className=\"showList\">\r\n                {renderRarityButtons}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default RarityButtons;","import React from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport MultiSelect from '../Templates/MultiSelect';\r\nimport { selectCardTypes } from '../../actions';\r\nimport '../../css/CardTypeDropdown.css';\r\n\r\nfunction CardTypeDropdown() {\r\n    const dispatch = useDispatch();\r\n\r\n    const selectedCardTypes = useSelector(state => state.displayOptions.cardTypes);\r\n    const key = useSelector(state => state.displayOptions.resetCount);\r\n\r\n    const cardTypes = ['Creature','Planeswalker','Instant','Sorcery','Artifact','Enchantment','Land'];\r\n    let options = [];\r\n    for (const type of cardTypes) {\r\n        options.push({text: type, val: type})\r\n    }\r\n\r\n    return (\r\n        <div className=\"cardTypes\">\r\n            <label > Select Card Type(s):</label>\r\n            <MultiSelect \r\n            options={options} noneSelectedText=\"All Types\"\r\n            selectedFn={(types) => dispatch(selectCardTypes(types))}\r\n            initialSelected={selectedCardTypes}\r\n            key={key}\r\n            />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CardTypeDropdown;","import React, { useState, useRef } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\n\r\nimport HoverPreview from '../Templates/HoverPreview';\r\nimport {\r\n    setCardModalContent, showCardModal, addCardToDeck, addCardToSideboard, changeCommander, changeCompanion, setAddType, setDragCard\r\n} from '../../actions';\r\nimport makeKeyboardClickable from '../../hooks/makeKeyboardClickable';\r\nimport useIsCardAddible from '../../hooks/useIsCardAddible';\r\nimport '../../css/CardListImage.css';\r\n\r\n/**\r\n * Describes a single image from the CardList, including its backside if applicable.\r\n */\r\nfunction CardListImage({ card, index, cardHeader, deckBuilder=false }) {\r\n    \r\n    const flipRef = useRef();\r\n    const cardRef = useRef();\r\n    const dispatch = useDispatch();\r\n    \r\n    const { addType } = useSelector(state => state.deckBuilder);\r\n\r\n    const isCardAddible = useIsCardAddible(card);\r\n    \r\n    // Destructure card properties for ease of access\r\n    const { name, card_faces, imgs } = card;\r\n    \r\n    // Track image side to be shown (front=true)\r\n    const [ imgSide, setImgSide ] = useState(true);\r\n    \r\n    // Variables that differ between the set view and the deck builder\r\n    let cardImages;\r\n    let flipButton = null; // Regular cards don't have a flip button\r\n    let onClick, onDragStart=null, onDragEnd=null;\r\n\r\n    /* Deck Builder */\r\n    if (deckBuilder) {\r\n        cardImages = <CardSide src={imgs.front} name={name} />; // No title because of hover preview\r\n\r\n        // Clicking will move the card from the card list to the desired portion of the deck\r\n        onClick = (e) => {\r\n\r\n            if (isCardAddible) {\r\n                switch (addType) {\r\n                    case \"deck\":\r\n                        dispatch(addCardToDeck(card));\r\n                        break;\r\n                    case \"sideboard\":\r\n                        dispatch(addCardToSideboard(card));\r\n                        break;\r\n                    case \"commander\":\r\n                        dispatch(changeCommander(card));\r\n                        dispatch(setAddType(\"deck\"));\r\n                        break;\r\n                    case \"companion\":\r\n                        dispatch(changeCompanion(card));\r\n                        dispatch(setAddType(\"deck\"));\r\n                        break;\r\n                    default: break;\r\n                }\r\n            }\r\n        }\r\n\r\n        onDragStart=() => {\r\n            if (isCardAddible) {\r\n                dispatch(setDragCard(card, 'collection', null));\r\n            }\r\n        }\r\n        onDragEnd=() => {\r\n            dispatch(setDragCard(null));\r\n        }\r\n    }\r\n    \r\n    /* Set View */\r\n    else {\r\n\r\n        // Clicking opens a modal to a larger view of the card\r\n        onClick = () => {\r\n            \r\n            // Get the index of the image on click\r\n            dispatch( setCardModalContent({ index, imgSide }) );\r\n            \r\n            // Then show the modal\r\n            dispatch( showCardModal(true) );\r\n        }\r\n\r\n        // Show flip button for 2-sided cards\r\n        if (imgs.back) {\r\n\r\n            flipButton = (\r\n                <button\r\n                    className={'circular ui icon button flipButton'}\r\n                    onClick={e => flip(e)}\r\n                    onKeyDown={e => {\r\n                        // If they hit enter\r\n                        if (e.key === \"Enter\" || e.key === \"Space\") {\r\n\r\n                            // Enter and space shouldn't do their default actions, just flip the card\r\n                            e.preventDefault();\r\n                            flip(e);\r\n                        }\r\n                    }}\r\n                    aria-label=\"Flip Card\" title=\"Flip Card\"\r\n                >\r\n                    <i className=\"undo icon\" ref={flipRef}/>\r\n                </button>\r\n            );\r\n\r\n            // Separate/create front and back cards\r\n            cardImages = <>\r\n                <CardSide src={imgs.front} name={name} title={card_faces[0].name} className=\"cardImg\"/>\r\n                <CardSide src={imgs.back}  name={name} title={card_faces[1].name} className=\"backside\"/>\r\n            </>;\r\n        }\r\n        // No back, so only make one img tag\r\n        else {\r\n            cardImages = <CardSide src={imgs.front} name={name} title={name}/>; // Includes title\r\n        }\r\n\r\n        /**\r\n         * Flips card and turns flip button\r\n         * @param {Event} event \r\n         */\r\n         function flip(event) {\r\n    \r\n            // Don't allow flip button click to propagate onto card\r\n            event.stopPropagation();\r\n            \r\n            // Set state for card side displayed\r\n            setImgSide(!imgSide);\r\n    \r\n            // Animate flip button\r\n            if (imgSide) {\r\n                flipRef.current.style.animation = \"rotate1 .6s linear\";\r\n            } else {\r\n                flipRef.current.style.animation = \"rotate2 .6s linear\";\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Putting all the pieces together except the hover preview for the deck builder\r\n    const compose = (\r\n\r\n        <div className={\"bouncy column\"} tabIndex=\"-1\" onKeyDown={e => makeKeyboardClickable(e, cardRef)}>\r\n\r\n            <div className=\"ui fluid card removeBoxShadow\">\r\n\r\n                {cardHeader}\r\n\r\n                <div \r\n                    className={imgSide ? \"image\" : \"flipped image\"} ref={cardRef} tabIndex=\"0\"\r\n                    onClick={onClick} onDragStart={onDragStart} onDragEnd={onDragEnd}\r\n                >\r\n                    {cardImages}\r\n                </div>\r\n            </div>\r\n            {flipButton}\r\n        </div>\r\n    );\r\n\r\n    // Return the card images wrapped in the hover preview if in deckbuilder\r\n    if (deckBuilder) {\r\n        return (\r\n            // Show preview when hovering\r\n            <HoverPreview imgs={imgs} >\r\n                {compose}\r\n            </HoverPreview>\r\n        );\r\n    }\r\n    // Other wise just return card images\r\n    return compose;\r\n}\r\n\r\nexport default CardListImage;\r\n\r\n/** Helper Component - makes defining card images simpler */\r\nfunction CardSide({ src, name, title=null, className=null }) {\r\n    return <img src={src} alt={name} aria-label={name} title={title} className={className} draggable='true' />;\r\n}\r\n","import { useSelector } from \"react-redux\";\r\n\r\n/**\r\n * A function that checks if a card is able to be added to a deck.\r\n * Checks if there are max copies of a card already in the decklist as well as if the card is legal in the desired deckType.\r\n * @param {object} card The card Object attempting to be added. Should contain at least name, type_line, and  legalities.\r\n * @returns {boolean} True if card can be added. False if it cannot be added\r\n */\r\nexport default function useIsCardAddible(card) {\r\n\r\n    const { deckMap, deckType, sideboardMap, commander, companion } = useSelector(state => state.deckBuilder);\r\n\r\n    // First check if the card is legal in the desired deckType\r\n    // For Custom and Limited, all cards are legal so skip this step\r\n    if (!(deckType === 'custom' || deckType === 'limited')) {\r\n\r\n        // If not legal in Format return false\r\n        if (card.legalities[deckType] !== 'legal'){\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Count the number of copies of the card already in deck\r\n    let copiesInDeck = 0; // Initialize\r\n\r\n    // Check the commander slot\r\n    if (commander && commander.name === card.name) {\r\n        copiesInDeck++;\r\n    }\r\n\r\n    // Check the companion slot\r\n    if (companion && companion.name === card.name) {\r\n        copiesInDeck++;\r\n    }\r\n    \r\n    // Check if the deck has any copies of the card\r\n    if ( deckMap[card.name] ) {\r\n\r\n        // Add up all versions of the card with the same name \r\n        for (const arenaId in deckMap[card.name]) {\r\n            copiesInDeck += deckMap[card.name][arenaId].copies;\r\n        }\r\n    }\r\n\r\n    // Check the sideboard\r\n    if ( sideboardMap[card.name] ) {\r\n        for (const arenaId in sideboardMap[card.name]) {\r\n            copiesInDeck += sideboardMap[card.name][arenaId].copies;\r\n        }\r\n    }\r\n    // Get the max number of copies allowed in a deck for this decktype\r\n    let maxCopies; \r\n    switch (deckType) {\r\n        case 'brawl':\r\n            maxCopies = 1;\r\n            break;\r\n        case 'limited':\r\n            maxCopies = 250; // Really it is unlimited but Arena has a total deck size limit of 250;\r\n            break;\r\n        default:\r\n            maxCopies = 4;\r\n            break;\r\n    }\r\n    // Some cards have special rules for how many are allowed in a deck, those exceptions will need to be explicit\r\n    switch ( card.name ) {\r\n        case \"Dragon's Approach\":\r\n            maxCopies = 250;\r\n            break;\r\n        case \"Persistent Petitioners\":\r\n            maxCopies = 250;\r\n            break;\r\n        case \"Rat Colony\":\r\n            maxCopies = 250;\r\n            break;\r\n        case \"Seven Dwarves\":\r\n            maxCopies = 7;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Decks can have any number of basic lands\r\n    if (card.type_line.includes('Basic') && card.type_line.includes('Land')) {\r\n        maxCopies = 250;\r\n    }\r\n\r\n    // If number of copies currently in deck < max copies allowed --> return true, Otherwise false\r\n    if (copiesInDeck < maxCopies) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","import React, { useState } from \"react\";\r\nimport { useDispatch } from \"react-redux\";\r\n\r\nimport { addCardToCollection, removeCardFromCollection } from \"../../actions\";\r\nimport '../../css/ManualCollectionButtons.css';\r\n\r\nfunction ManualCollectionButtons({ children, card }) {\r\n    const dispatch = useDispatch();\r\n    const [ hovering, setHovering ] = useState(\"invisible\");\r\n\r\n    return (\r\n        <div \r\n            id=\"ManualCollectionButtons\"\r\n            onMouseEnter={() => setHovering(\"\")}\r\n            onMouseLeave={() => setHovering(\"invisible\")}\r\n        >\r\n            <button\r\n                className={hovering}\r\n                onClick={() => dispatch(removeCardFromCollection(card))}\r\n                onKeyDown={(e) => {\r\n                    if (e.key === \"Enter\") {\r\n                        e.stopPropagation();\r\n                    }\r\n                }}\r\n            >\r\n                <i className=\"minus icon\"></i>\r\n            </button>\r\n            {children}\r\n            <button\r\n                className={hovering}\r\n                onClick={() => dispatch(addCardToCollection(card))}\r\n                onKeyDown={(e) => {\r\n                    if (e.key === \"Enter\") {\r\n                        e.stopPropagation();\r\n                    }\r\n                }}\r\n            >\r\n                <i className=\"plus icon\"></i>\r\n            </button>\r\n        </div>\r\n    );\r\n    \r\n}\r\n\r\nexport default ManualCollectionButtons;\r\n","import React, { useState, useEffect, useRef, useMemo } from 'react';\r\n\r\n/**\r\n * Wrap around children to stop them from being rendered to the DOM until they are within about one 'view height' + buffer\r\n * of the parent element. Assumes that all child elements are the same size for calculating when to show them.\r\n * \r\n * @prop {number} childHeight Height of child elements, including margin/padding.\r\n * @prop {number} childWidth Width of child elements, including margin/padding.\r\n * @prop {number} [gap=0] (Optional) Gap between child elements (in a flexbox).\r\n * @prop {number} [buffer=2] Number of rows of cards to load beyond the current screen.\r\n * @prop {string} [scrollingParent=null] (Optional) Specify this string if the element that scrolls is not the window.\r\n * Input to document.querySelector() that selects the scrolling parent of LazyLoad.\r\n * @prop {function} [viewWidthFn=null] (Optional) A transformation to apply to the calculation of the view width. View width\r\n * is initially the offsetWidth of the parent or window.innerWidth if scrollingParent is unspecified.\r\n * @prop {function} [viewHeightFn=null] (Optional) A transformation to apply to the calculation of the view height. View height\r\n * is initially the offsetHeight of the parent or window.innerHeight if scrollingParent is unspecified.\r\n * @returns React.Component that should be wrapped around children that will be lazily loaded.\r\n */\r\nfunction LazyLoad({ \r\n    children, childHeight, childWidth, gap=0, buffer=2, \r\n    scrollingParent=null, viewWidthFn=null, viewHeightFn=null\r\n}) {\r\n\r\n    // Get parent element\r\n    let parent = window;\r\n    let viewHeight = parent.innerHeight;\r\n    let viewWidth = parent.innerWidth;\r\n\r\n    // Check if a parent element other than the window is specified\r\n    if (scrollingParent) {\r\n        const element = document.querySelector(scrollingParent);\r\n\r\n        // Make sure the query string returned something\r\n        if (element) {\r\n\r\n            // Then update parent and call specific height/width properties\r\n            parent = element;\r\n            viewHeight = parent.offsetHeight;\r\n            viewWidth = parent.offsetWidth;\r\n        }\r\n    }\r\n\r\n    // Apply transformations to height and width if applicable\r\n    if (viewHeightFn) {\r\n        viewHeight = viewHeightFn(viewHeight);\r\n    }\r\n    if (viewWidthFn) {\r\n        viewWidth = viewWidthFn(viewWidth);\r\n    }\r\n\r\n    // Calculate the number of children that can fit in a row\r\n    const childrenPerRow = useMemo(() => {\r\n\r\n        // From: NumberChildren * ChildWidth + (NumberChildren - 1) * GapWidth <= ParentWidth\r\n        return Math.floor( (viewWidth + gap) / (childWidth + gap) );\r\n    }, [viewWidth, childWidth, gap]);\r\n\r\n    // Track number of children currently shown\r\n    const [numChildrenShown, setNumChildrenShown] = useState(buffer*childrenPerRow);\r\n\r\n    // Calculate container height to set so scrollbar is about the right size\r\n    const height =  Math.ceil(children.length/childrenPerRow) * childHeight;\r\n\r\n    // Track whether the throttle function is currently active\r\n    const throttleActive = useRef(false); // throttleActive.current = false;\r\n\r\n    // Add listener for Y scrolling on page load or resize\r\n    useEffect(() => {\r\n        \r\n        // Watch for scrolling and compute number of children to show\r\n        function onScrollY() { // Function to throttle\r\n\r\n            const scrollY = scrollingParent ? parent.scrollTop : parent.scrollY;\r\n\r\n            // Calculate number of children to show\r\n            const numChildrenWeNeedToShow = Math.ceil((scrollY + viewHeight) / childHeight) * childrenPerRow;\r\n\r\n            // Increment number of children to show if user scrolls down\r\n            if (numChildrenWeNeedToShow + buffer*childrenPerRow > numChildrenShown) {\r\n                setNumChildrenShown(numChildrenWeNeedToShow + buffer*childrenPerRow);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Allows the \"throttledFunction\" to be run, at most, every \"delay\" milliseconds.\r\n         * Ignores susequent calls to \"throttledFunction\" within the delay period.\r\n         * \r\n         * @param {function} throttledFunction Function to throttle\r\n         * @param {number} delay Number of milliseconds to throttle \"throttledFunction\"\r\n         */\r\n         function throttle(throttledFunction, delay) {\r\n\r\n            // Only accept new function call when throttle is not active\r\n            if (!throttleActive.current) {\r\n\r\n                // Set throttle to active state\r\n                throttleActive.current = true;\r\n\r\n                // After \"delay\" milliseconds, run the throttledFunction and clear \"active\" status of throttle\r\n                setTimeout(() => {\r\n\r\n                    // Clear the active status of throttle\r\n                    throttleActive.current = false;\r\n\r\n                    // Run the throttled function\r\n                    throttledFunction();\r\n                }, delay);\r\n            }\r\n        }\r\n\r\n        // Throttle onScrollY so it's only called, at most, every 200ms\r\n        const throttledOnScrollY = ( () => throttle(onScrollY, 200) );\r\n\r\n        // Track scrolling\r\n        parent.addEventListener(\"scroll\", throttledOnScrollY);\r\n        \r\n        // Cleanup\r\n        return () => parent.removeEventListener(\"scroll\", throttledOnScrollY);\r\n\r\n    }, [buffer, childHeight, childrenPerRow, numChildrenShown, parent, scrollingParent, viewHeight]);\r\n\r\n    // Set height of lazyload div so scroll bar shows true length\r\n    return (\r\n        <div className=\"lazyLoad\" style={{ \"minHeight\" : `${height}px` }} >\r\n\r\n            {/* Only show children if they've been scrolled to */ }\r\n            {children.slice(0, numChildrenShown)}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default LazyLoad;\r\n","import React, { useEffect, useMemo } from 'react';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\n\r\nimport CardListImage from './CardListImage';\r\nimport ManualCollectionButtons from '../SetDetails/ManualCollectionButtons';\r\nimport LazyLoad from '../Templates/LazyLoad';\r\nimport findCards from '../../data/findCards';\r\nimport { updateImageList } from '../../actions';\r\nimport '../../css/CardList.css';\r\n\r\n/**\r\n * The list of MTG Arena cards.\r\n * \r\n * @param {string} [setId=null] (Optional) three letter set code. Can also specify using redux.\r\n * @param {string} [scrollingParent=null] (Optional) Specify this string if the element that scrolls is not the window.\r\n * Input to document.querySelector() that selects the scrolling parent of CardList.\r\n * @returns Returns a grid of images of card in the set using filter options that are retrieved from redux store. Also displays \r\n * the number of cards owned by the user above each card image. \r\n */\r\nfunction CardList({ setId=null, scrollingParent=null, deckBuilder }) {\r\n    \r\n    // Get values from redux state\r\n    const { cardCollection } = useSelector(state => state.inventory);\r\n\r\n    const {\r\n        colors, searchTerm, searchType, showCards, cardCount, cmcs,\r\n        booster: boosterVal, set: reduxSets, cardTypes: reduxCardTypes, rarity: rarities,\r\n    } = useSelector(state => state.displayOptions);\r\n\r\n    const {\r\n        deckMap, sideboardMap, commander, companion, addBasics, deckType: reduxDeckType, addType,\r\n    } = useSelector(state => state.deckBuilder);\r\n\r\n    // Access redux dispatch\r\n    const dispatch = useDispatch();\r\n    \r\n    // Get the cards using the findCards Function\r\n    const cards = useMemo(() => {\r\n\r\n        // If all/none of the rarities selected, set rarityOption to undefined so findCards will not filter by rarity\r\n        let rarityOption = [];\r\n        for (const rarity in rarities) {\r\n\r\n            // Add rarity to rarityOption if it's selected\r\n            if (rarities[rarity]) {\r\n                rarityOption.push(rarity);\r\n            }\r\n        }\r\n\r\n        // Set rarityOption to undefined if all or none of the rarities are added to it\r\n        if (rarityOption.length < 1 || rarityOption.length > 3) {\r\n            rarityOption = undefined;\r\n        }\r\n        // Set booster to true, false, or undefined based on the value in redux\r\n        let booster;\r\n        switch (boosterVal) {\r\n            case \"In Boosters\":\r\n                booster = true;\r\n                break;\r\n            case \"Not In Boosters\":\r\n                booster = false;\r\n                break;\r\n            case \"All Cards\":\r\n                booster = undefined;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // Determine if set passed in as prop or received from redux\r\n        // Initialize set variable for use in searchOptions\r\n        let set;\r\n        // If a single SetId is provided --> use it\r\n        if (setId) {\r\n            set = setId;\r\n\r\n            // Otherwise get value(s) from redux \r\n        } else {\r\n\r\n            // If the redux value is empty, set = undefined so that findcards will disregard filtering by set\r\n            if (reduxSets.length === 0 ) {\r\n                set = undefined;\r\n\r\n            // If reduxSets has info, they need be altered so that set is an array of 3 letter set codes\r\n            } else {\r\n                set = [];\r\n                for ( const setObj of reduxSets) {\r\n                    set.push(setObj.val)\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Make cardTypes retrieved from redux into a usable form for findCards\r\n        // Currently is an array of objects --> Need just simple array\r\n\r\n        let cardTypes = undefined; // Initialize as undefined for case where reduxcardTypes is empty\r\n\r\n        if ( reduxCardTypes.length >= 1 ) {\r\n            cardTypes = []; // Change to empty array to add push method \r\n\r\n            for (const cardType of reduxCardTypes) {\r\n                // Only push the value property from reduxCardTypes into array\r\n                cardTypes.push(cardType.val);\r\n            }\r\n        }\r\n\r\n        // Make cmcs usuable for findCards\r\n        let selectedCMCs = undefined;\r\n        \r\n        if ( cmcs.length >= 1 ) {\r\n            selectedCMCs = [];\r\n            \r\n            for ( const cmc of cmcs) {\r\n                selectedCMCs.push(cmc.val);\r\n            }\r\n        }\r\n\r\n        // Set the decktype for searchOptions\r\n        let deckType = reduxDeckType;\r\n        // Ignore decktype when not in deckbuilder --> set to undefined\r\n        // Also if the redux value for deckType is limited or custom --> set to undefined because those modes have no specific legalities\r\n        if (!deckBuilder || reduxDeckType === 'limited' || reduxDeckType === 'custom') {\r\n            deckType = undefined;\r\n        }\r\n        \r\n        // Put all search options into a single object for findCards function\r\n        let searchOptions = {\r\n            set: set, color: colors, booster: booster, rarity: rarityOption, term: searchTerm,\r\n            advancedSearchType: searchType, cmcs: selectedCMCs, deckType: deckType, cardTypes: cardTypes\r\n        };\r\n\r\n        if (deckBuilder) {\r\n            \r\n            // If we are in the deckbuilder and are adding basic lands, we need different searchOptions\r\n            if (addBasics) {\r\n                searchOptions = { ...searchOptions, excludeBasicLands: false, cmcs: undefined, rarity: undefined, cardTypes: undefined}\r\n            }\r\n            // addType is used to show only commanders or companions. Not used when searching basic lands\r\n            else {\r\n                searchOptions.addType = addType;\r\n            }\r\n        }\r\n        \r\n        return findCards(searchOptions);\r\n        \r\n    }, [boosterVal, setId, reduxCardTypes, cmcs, reduxDeckType, deckBuilder, colors, searchTerm, searchType, rarities, reduxSets, addBasics, addType]);\r\n\r\n    // Track currently shown pictures\r\n    let currentPictures = [];\r\n\r\n    // Render cards based on how many the user owns using logic in 'showCards'\r\n    const renderCards = useMemo(() => {\r\n        let returnCards = [];\r\n        for (const card of cards) {\r\n\r\n            // Get number of card owned, if any\r\n            const numOwned = cardCollection[card.arenaId] ? cardCollection[card.arenaId] : 0;\r\n\r\n            // Initialize makeCard Boolean to false\r\n            let makeCard = false;\r\n\r\n            // Execute logic from showCards variable to determine whether card should be made\r\n            if (( showCards === 'Show All Cards' )                         ||\r\n                ( showCards === 'Own None' && numOwned === 0 )             ||\r\n                ( showCards === 'Own at Least One' && numOwned  >  0 )     ||\r\n                ( showCards === 'Missing at Least One' && numOwned  <  4 ) ||\r\n                ( showCards === 'Own Full Playset' && numOwned === 4))\r\n            {\r\n                makeCard = true;\r\n            }\r\n\r\n            // Don't make card if showCards logic says not to\r\n            if ( !makeCard ) {\r\n                continue;\r\n            }\r\n\r\n            // Track images to be displayed\r\n            currentPictures.push(card.imgs);\r\n\r\n            // Build card header\r\n            let cardHeader;\r\n\r\n            // Card Header for set view; number owned and buttons to change number owned\r\n            if (!deckBuilder) {\r\n                \r\n                cardHeader = (\r\n                    <ManualCollectionButtons card={card}>\r\n                        <div className=\"numOwned\" > {numOwned} / 4 </div>\r\n                    </ManualCollectionButtons>\r\n                );\r\n            }\r\n            \r\n            // In the deck builder, the card header indicates how many are owned as well as how many copies are in the deck\r\n            else {\r\n\r\n                // Circles are filled if owned and colored if added to deck\r\n                const circles = (() => {\r\n                    let temp = [];\r\n\r\n                    // Circles are declared left to right, but, if owned, filled right to left\r\n                    for (let i=0; i<4; i++) {\r\n\r\n                        // Initially assume circle is filled (owned copy of card)\r\n                        let circleClass = 'icon circle';\r\n\r\n                        // Check if circle should be an outline (not owned copy of card)\r\n                        if (i >= numOwned) {\r\n                            circleClass += ' outline';\r\n                        }\r\n\r\n                        // Get number of copies in deck and sideboard\r\n                        let copiesInDeck = 0;\r\n\r\n                        // Count the commander\r\n                        if (commander && commander.arenaId === card.arenaId) {\r\n                            copiesInDeck++;\r\n                        }\r\n\r\n                        if (companion && companion.arenaId === card.arenaId) {\r\n                            copiesInDeck++;\r\n                        }\r\n\r\n                        // Count the copies in the main deck\r\n                        if (deckMap[card.name] && deckMap[card.name][card.arenaId]) {\r\n                            copiesInDeck += deckMap[card.name][card.arenaId].copies;\r\n                        }\r\n                        // Count the copies in the sideboard\r\n                        if (sideboardMap[card.name] && sideboardMap[card.name][card.arenaId]) {\r\n                            copiesInDeck += sideboardMap[card.name][card.arenaId].copies;\r\n                        }\r\n\r\n                        // Color circles for number of cards in deck\r\n                        if (copiesInDeck && i < copiesInDeck) {\r\n                            circleClass += ' inDeck';\r\n                        }\r\n\r\n                        // Add circle to temp array\r\n                        temp.push(<i className={circleClass} key={`cir${i}_${card.arenaId}`}/>)\r\n                    }\r\n                    return temp;\r\n                })();\r\n\r\n\r\n                cardHeader = (\r\n                    <div className=\"content\">\r\n                        <div className=\"deckBuilder_circles\">\r\n                            {circles}\r\n                        </div>\r\n                    </div>\r\n                );\r\n            }\r\n\r\n            // Build card JSX\r\n            returnCards.push(\r\n                <CardListImage\r\n                    card={card} index={currentPictures.indexOf(card.imgs)} cardHeader={cardHeader} deckBuilder={deckBuilder}\r\n                    key= {`${card.set}${card.collector_number}`}\r\n                />\r\n            );\r\n            \r\n        }\r\n        return returnCards;\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [cardCollection, cards, showCards, deckBuilder, deckMap, sideboardMap, commander, companion]);\r\n\r\n    // Track card images displayed, but only update redux state after JSX done rendering\r\n    useEffect( () => {\r\n        dispatch(updateImageList(currentPictures));\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [renderCards] );\r\n    \r\n    // Declare card dimensions for lazy loading\r\n    let width, height, gap, buffer, viewWidthFn;\r\n    if (deckBuilder) {\r\n        width = 160;\r\n        height = 257.5;\r\n        gap = 10;\r\n        buffer = 4;\r\n        viewWidthFn = viewWidth => viewWidth - 10;\r\n    } else {\r\n        width = 225;\r\n        height = 351.75;\r\n        gap = 20;\r\n        buffer = 3;\r\n        viewWidthFn = viewWidth => viewWidth - 17;\r\n    }\r\n\r\n    return (<>\r\n        {/* Counter for number of cards being displayed */}\r\n        {!deckBuilder ? <p id=\"displayingNumberCards\">\r\n            Displaying <span className=\"numCardsShown\">{cardCount}</span> card(s):\r\n        </p> : null}\r\n\r\n        {/* JSX for matching cards */}\r\n        <div className=\"cardList-cards\" >\r\n            <LazyLoad \r\n                childWidth={width} childHeight={height} gap={gap} buffer={buffer}\r\n                scrollingParent={scrollingParent} viewWidthFn={viewWidthFn}\r\n            >\r\n                {renderCards}\r\n            </LazyLoad>\r\n        </div>\r\n    </>);\r\n}\r\n\r\nexport default CardList;\r\n"],"sourceRoot":""}